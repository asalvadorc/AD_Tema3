{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acc\u00e9s a Dades","title":"Acc\u00e9s a Dades"},{"location":"#acces-a-dades","text":"","title":"Acc\u00e9s a Dades"},{"location":"AD_T3_Fitxers_de_diferents_formats/1_fitxers_binaris_amb_formats_especfics/","text":"Acc\u00e9s a Dades 1.- Fitxers binaris amb formats espec\u00edfics DataInputStream i DataOutputStream Ja hem vist com utilitzar els fitxers de car\u00e0cters i tamb\u00e9 de bytes. Per\u00f2 en aquest \u00faltim cas sempre ha estat per a llegir o escriure byte a byte, fins al final de fitxer. Ens plantegem ara com utilitzar els fitxer per a guardar dades estructurades de tipus b\u00e0sics diferents . De moment no seran complicades per\u00f2 enseguida veurem que ens fa falta alguna cosa per a poder treballar c\u00f2modament. Suposem un exemple d'una empresa que vol guardar dades dels seus empleats. Concretament vol guardar el n\u00famero d'empleat, el nom, el departament al qual pertany, l'edat i el sou. N\u00famero | Nom | Depart | Edat | Sou ---|---|---|---|--- 1 | Andreu | 10 | 32 | 1000.00 2 | Bernat | 20 | 28 | 1200.00 3 | Claudia | 10 | 26 | 1100.00 4 | Dami\u00e0 | 10 | 40 | 1500.00 Ja es veu que les dades s\u00f3n de difrents tipus. Si tot f\u00f3ra de text no hi hauria problema. Per\u00f2 si considerem les dades com a num\u00e8riques enteres o reals no ens serveixen els Stream de car\u00e0cters (Reader i Writer). Per tant hem d'anar a InputStream i OutputStream, per\u00f2 seria molt dur treballar directament amb bytes. Haur\u00edem de saber exactament quants bytes ocupa cada dada: int utilitza 4 bytes; short utilitza 2 bytes, byte utilitza 1 byte, i long utilitza 8 bytes; en el cas dels reals, float utilitza 4 bytes i double utilitza 8 bytes. Massa varietat i massa fiena recordar-los tots. Ens falta doncs una ajuda per a poder guardar i recuperar dades d'aquestos diferents tipus. Aquesta funcionalitat ens la proporciona la parella DataInputStream i DataOutputStream , que s\u00f3n decoradors dels Stream i que disposen de m\u00e8todes per a guardar o recuperar dades de diferents tipus, sense haver de saber el format intern de cadascun ni quants bytes ocupen. En la seg\u00fcent taula tenim uns quants m\u00e8todes d'aquestos: DataInputStream Explicaci\u00f3 DataOutputStream byte readByte () Un byte void writeByte (int) short readShort () Un enter xicotet (2 bytes) void writeShort (short) int readInt () Un enter (4 bytes) void writeInt (int) long readLong () Un enter llarg (8 bytes) void writeLong (long) float readFloat () Un real en simple precisi\u00f3 void writeFloat (flaot) double readDouble () Un real en doble precisi\u00f3 void writeDouble (double) char readChar () Un car\u00e0cter Unicode (16 bits) void writeChar (int) String readUTF () Una cadena de car\u00e0cters UTF-8 i la converteix en String (16 bits) void writeUTF (String) Anem a veure l'exemple, en el qual guardarem en un fitxer anomenat Empleats.dat les dades dels 4 empleats. Per comoditat ens els definirem en arrays de 4 elements: un array per als noms, un altre per als departaments, etc. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_1_CrearEmpleats.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats.dat\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } I aquesta seria la recuperaci\u00f3 de les dades. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_2_ConsultarEmpleats.kt package exemples import java.io.FileInputStream import java.io.DataInputStream fun main(args: Array<String>) { val f = DataInputStream(FileInputStream(\"Empleats.dat\")) while (f.available() > 0) { System.out.println(\"N\u00famero: \" + f.readInt()) System.out.println(\"Nom: \" + f.readUTF()) System.out.println(\"Depart: \" + f.readInt()) System.out.println(\"Edat: \" + f.readInt()) System.out.println(\"Sou: \" + f.readDouble()) System.out.println() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.- Fitxers binaris amb formats espec\u00edfics"},{"location":"AD_T3_Fitxers_de_diferents_formats/1_fitxers_binaris_amb_formats_especfics/#1-fitxers-binaris-amb-formats-especifics","text":"DataInputStream i DataOutputStream Ja hem vist com utilitzar els fitxers de car\u00e0cters i tamb\u00e9 de bytes. Per\u00f2 en aquest \u00faltim cas sempre ha estat per a llegir o escriure byte a byte, fins al final de fitxer. Ens plantegem ara com utilitzar els fitxer per a guardar dades estructurades de tipus b\u00e0sics diferents . De moment no seran complicades per\u00f2 enseguida veurem que ens fa falta alguna cosa per a poder treballar c\u00f2modament. Suposem un exemple d'una empresa que vol guardar dades dels seus empleats. Concretament vol guardar el n\u00famero d'empleat, el nom, el departament al qual pertany, l'edat i el sou. N\u00famero | Nom | Depart | Edat | Sou ---|---|---|---|--- 1 | Andreu | 10 | 32 | 1000.00 2 | Bernat | 20 | 28 | 1200.00 3 | Claudia | 10 | 26 | 1100.00 4 | Dami\u00e0 | 10 | 40 | 1500.00 Ja es veu que les dades s\u00f3n de difrents tipus. Si tot f\u00f3ra de text no hi hauria problema. Per\u00f2 si considerem les dades com a num\u00e8riques enteres o reals no ens serveixen els Stream de car\u00e0cters (Reader i Writer). Per tant hem d'anar a InputStream i OutputStream, per\u00f2 seria molt dur treballar directament amb bytes. Haur\u00edem de saber exactament quants bytes ocupa cada dada: int utilitza 4 bytes; short utilitza 2 bytes, byte utilitza 1 byte, i long utilitza 8 bytes; en el cas dels reals, float utilitza 4 bytes i double utilitza 8 bytes. Massa varietat i massa fiena recordar-los tots. Ens falta doncs una ajuda per a poder guardar i recuperar dades d'aquestos diferents tipus. Aquesta funcionalitat ens la proporciona la parella DataInputStream i DataOutputStream , que s\u00f3n decoradors dels Stream i que disposen de m\u00e8todes per a guardar o recuperar dades de diferents tipus, sense haver de saber el format intern de cadascun ni quants bytes ocupen. En la seg\u00fcent taula tenim uns quants m\u00e8todes d'aquestos: DataInputStream Explicaci\u00f3 DataOutputStream byte readByte () Un byte void writeByte (int) short readShort () Un enter xicotet (2 bytes) void writeShort (short) int readInt () Un enter (4 bytes) void writeInt (int) long readLong () Un enter llarg (8 bytes) void writeLong (long) float readFloat () Un real en simple precisi\u00f3 void writeFloat (flaot) double readDouble () Un real en doble precisi\u00f3 void writeDouble (double) char readChar () Un car\u00e0cter Unicode (16 bits) void writeChar (int) String readUTF () Una cadena de car\u00e0cters UTF-8 i la converteix en String (16 bits) void writeUTF (String) Anem a veure l'exemple, en el qual guardarem en un fitxer anomenat Empleats.dat les dades dels 4 empleats. Per comoditat ens els definirem en arrays de 4 elements: un array per als noms, un altre per als departaments, etc. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_1_CrearEmpleats.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats.dat\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } I aquesta seria la recuperaci\u00f3 de les dades. Enganxeu el seg\u00fcent codi en un fitxer de Kotlin anomenat Exemple_3_1_2_ConsultarEmpleats.kt package exemples import java.io.FileInputStream import java.io.DataInputStream fun main(args: Array<String>) { val f = DataInputStream(FileInputStream(\"Empleats.dat\")) while (f.available() > 0) { System.out.println(\"N\u00famero: \" + f.readInt()) System.out.println(\"Nom: \" + f.readUTF()) System.out.println(\"Depart: \" + f.readInt()) System.out.println(\"Edat: \" + f.readInt()) System.out.println(\"Sou: \" + f.readDouble()) System.out.println() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.- Fitxers binaris amb formats espec\u00edfics"},{"location":"AD_T3_Fitxers_de_diferents_formats/2_accs_directe_a_fitxers/","text":"Acc\u00e9s a Dades 2.- Acc\u00e9s directe a fitxers Els exemples de l'apartat anterior ens poden fer reflexionar sobre un altre tipus d'acc\u00e9s als fitxers. De moment tots els accessos que hem fet als fitxers, tant binaris com de car\u00e0cter, ha estat seq\u00fcencials . Aix\u00f2 vol dir que sempre comencem pel principi del fitxer fins que arribem a la informaci\u00f3 que volem, o en la major part dels casos fins el final de fitxer. Per\u00f2, i si volem \u00fanicament una determinada informaci\u00f3? En l'exemple de l'apartat anterior, qu\u00e8 haur\u00edem de fer si volgu\u00e9rem nom\u00e9s la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia)? Doncs haur\u00edem de passar primer per tots els anteriors. Com nom\u00e9s hi ha 2 davant, no sembla molta feina, per\u00f2 \u00e9s f\u00e0cil de veure la dificultat (o millor dit el cost) si el fitxer constara de centenars o milers d'empleats. Suposem un fitxer de 10.000 empleats. Si volem accedir a l'empleat 9.500 haur\u00edem de passar pels 9.499 empleats anteriors, ja que l'acc\u00e9s seq\u00fcencial obliga a comen\u00e7ar pel principi i anar passant fins que trobem la informaci\u00f3. I encara pitjor: i si despr\u00e9s de consultar l'empleat 9.500 ara volem consultar el 9.000? Doncs haur\u00edem de comen\u00e7ar des del principi, perqu\u00e8 ja ens l'hav\u00edem passat. Afortunadament i ha una altra manera d'accedir, un altre tipus d'acc\u00e9s. S'anomena acc\u00e9s directe perqu\u00e8 permetr\u00e0 anar directament a una posici\u00f3 determinada del fitxer. Moltes vegades tamb\u00e9 es diu acc\u00e9s relatiu o acc\u00e9s aleatori , per\u00f2 el funcionament sempre \u00e9s el mateix. I mireu que estem parlant d'acc\u00e9s. Per tant el que canviar\u00e0 no \u00e9s la classe File sin\u00f3 qui permet accedir al contingut, \u00e9s a dir les classes de flux d'informaci\u00f3 (els Streams). Les classes InputStream-OutputStream i Reader-Writer nom\u00e9s permeten l'acc\u00e9s seq\u00fcencial. Per tant per a l'acc\u00e9s directe disposarem d'una altra classe que ens permetr\u00e0 fer totes les operacions, tant de lectura com d'escriptura. T\u00e9 l'avantatge que disposa de molts m\u00e8todes per a poder accedir a la informaci\u00f3. No ens fara falta, per tant, les classes \"decoradores\" que afegeixen funcionalitats. Amb aquesta classe tindrem suficient. RandomAccessFile La classe RandomAccessFile ens permetr\u00e0 accedir de forma directa a un fitxer. No ens far\u00e0 falta, en principi, cap altra classe m\u00e9s. Ens proporcionar\u00e0 tota la funcionalitat necess\u00e0ria. En els constructors aniran 2 par\u00e0metres. El primer far\u00e0 refer\u00e8ncia al fitxer. El segon al mode d'acc\u00e9s: nom\u00e9s lectura ( r ) o lectura-escriptura ( rw ). RandomAccessFile(fitxer: File, mode: String) RandomAccessFile(fitxer: String, mode: String) En el primer cas li especifiquem un File en el primer par\u00e0metre. En el segon un String que correspondr\u00e0 amb el nom del fitxer En ambd\u00f3s casos, el segon par\u00e0metre indicar\u00e0 el mode: \"r\" indica nom\u00e9s lectura \"rw\" indica lectura escriptura A pesar de ser una classe completament diferent de la jerarquia de InputStream-OutpuStream (o Readre-Writer ) implementa m\u00e8todes que es diuen exactament igual que els d'aquelles classes, cosa que fa molt m\u00e9s c\u00f2moda la utilitzaci\u00f3. Els m\u00e8todes m\u00e9s importants s\u00f3n: M\u00e8tode Explicaci\u00f3 M\u00e8tode int read() llig (escriu) un byte (encara aix\u00ed torna o se li passa un enter) void write(int) int read(byte[]) llig (escriu) un s\u00e8rie de bytes, tants com la grand\u00e0ria de l'array (si pot) int write(byte[]) byte readByte() llig (escriu) un byte interpretat com n\u00famero de 8 bits amb signe void writeByte(int) char readChar() llig (escriu) un car\u00e0cter void write(char) int readInt() llig (escriu) un enter (4 bytes) void write(int) short readShort() llig (escriu) un enter xicotet (2 bytes) void write(short) long readLong() llig (escriu) un enter llarg (8 bytes) void write(long) float readFloat() llig (escriu) un n\u00famero real en simple precisi\u00f3 (4 bytes) void write(float) double readDouble() llig (escriu) un n\u00famero real en doble precisi\u00f3 (8 bytes) void write(double) String readUTF() llig (escriu) un cadena de car\u00e0cters (interpretat com UTF-8) void writeUTF() void seek(long) situa el punter en la posici\u00f3, mesurat des del principi del fitxer long length() torna la grand\u00e0ria del fitxer void close() Tanca el flux de l'acc\u00e9s directe En cada lectura, despr\u00e9s de llegir el punter que apunta al fitxer estar\u00e0 situat despr\u00e9s de la dada llegida, siga quina siga la grand\u00e0ria. Anem a veure un exemple utilitzant el fitxer Empleats.dat creat en l'apartat anterior. Obrim l'acc\u00e9s directe \u00fanicament en mode lectura, i ens situem directament a la posici\u00f3 56, que \u00e9s on comen\u00e7a la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia). Posteriorment utilitzem el m\u00e8tode de lectura apropiat per a cada tipus de dada. Copieu el codi seg\u00fcent en un fitxer de kotlin anomenat Exemple_3_2_1_EmpleatsDirecte.kt package exemples import java.io.RandomAccessFile fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats.dat\", \"r\") f.seek(56) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) f.close() } R\u00e0pidament observem una cosa: com sab\u00edem que ens hav\u00edem de situar en la posici\u00f3 56? I si els noms del dos primers hagueren sigut m\u00e9s llargs o m\u00e9s curts? Per a poder solucionar els problemes anteriors, podr\u00edem fer que els noms siguen de llarg\u00e0ria fixa. Les altres dades no donen problemes. Intentarem ara donar sempre una grand\u00e0ria de 10 car\u00e0cters a cada nom (si sospit\u00e0rem que no en tenim prou, haur\u00edem de fer-los m\u00e9s grans). Anem a crear el fitxer Empleats2.dat , i ser\u00e0 exactament igual al de l'anterior apartat, excepte que en el moment de posar els noms (en un array de strings) posem exactament 10 car\u00e0cters, omplint amb blancs si \u00e9s necessari. Evidentment, aquesta no \u00e9s l'\u00fanica manera, per\u00f2 per a les poques dades que tenim, s\u00ed la m\u00e9s r\u00e0pida. val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") La sent\u00e8ncia anterior \u00e9s l'\u00fanica difer\u00e8ncia respecte al programa de creaci\u00f3 d'Empleats.dat de la pregunta anterior, a banda del nom del fitxer, que ara ser\u00e0 Empleat2.dat :. Copieu el seg\u00fcent codi en el fitxer Kotlin: Exemple_3_2_2_Crear_Empleats2.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats2.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Ara que sabem la grand\u00e0ria exacta del nom, podem saber que la informaci\u00f3 de cada empleat \u00e9s: N\u00famero d'empleat (enter) 4 bytes Nom (10 car\u00e0cters + 2 bytes) 10 + 2 bytes Departament (enter) 4 bytes Edat (enter) 4 bytes Sou (doble precisi\u00f3) 8 bytes **Total: ** **32 bytes ** Sabent que cada registre (la informaci\u00f3 de cada empleat) ocupa 32 bytes, sembla f\u00e0cil anar a un determinat empleat. Per a poder provar-lo b\u00e9, introduirem el n\u00famero d'empleat per teclat, fins introduir 0. Observeu que si s'introdueix 1, hem d'anar a pel primer registre, que est\u00e0 a principi de fitxer. Si introdu\u00efm 2, anem a pel segon, que nom\u00e9s en t\u00e9 un davant, per tant 32 bytes. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_3_Empleats2Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats2.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt () while (num != -1) { f.seek(32 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } El problema ara tamb\u00e9 sembla obvi. Hem assumit que cada car\u00e0cter ocupa un byte. Com es codificar\u00e0 en UTF-8, mentre siguen car\u00e0cters normals aix\u00ed ser\u00e0. Per\u00f2 qu\u00e8 passar\u00e0 quan hi haja un car\u00e0cter accentuat? Que ocupar\u00e0 2 car\u00e0cters. Aix\u00ed, com Cl\u00e0udia t\u00e9 un d'aquestos car\u00e0cters, la cadena no ocupar\u00e0 10+2 = 12 bytes, sin\u00f3 13. Aleshores, si intentem anar al quart empleat, ens donar\u00e0 problemes. La manera de solucionar-lo ser\u00e0 escriure de manera que tots els car\u00e0cters ocupen sempre el mateix. Hi ha un m\u00e8tode que ens ho permet: writeChars . Guardar\u00e0 cada car\u00e0cter amb dos bytes, i no es guardar\u00e0 la llarg\u00e0ria de la cadena. Podem intentar utilitzar-lo per construir el fitxer Empleats3.dat . Nom\u00e9s haurem de substituir la seg\u00fcent sent\u00e8ncia: f.writeChars(noms[i]) a banda del nom del fitxer, clar. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_4_CrearEmpleat3.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats3.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeChars(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Lamentablement la lectura no \u00e9s tan f\u00e0cil. Haurem de llegir exactament 10 car\u00e0cters (podr\u00edem utilitzar algun altre m\u00e8tode, per\u00f2 el que es mostra permet identificar clarament que es llegiran 10 car\u00e0cters). Els anirem acumulant en un String poder mostrar-lo. Recordeu tamb\u00e9 que ara el nom ocupa 20 bytes, que sumats als altres 20 de les altres dades fan un total de 40 bytes per registre. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_2_5_Empleats3Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats3.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt() while (num != -1) { f.seek(40 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) var nom = \"\" for (i in 1..10) nom += f.readChar() println(\"Nom: \" + nom) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.- Acc\u00e9s directe a fitxers"},{"location":"AD_T3_Fitxers_de_diferents_formats/2_accs_directe_a_fitxers/#2-acces-directe-a-fitxers","text":"Els exemples de l'apartat anterior ens poden fer reflexionar sobre un altre tipus d'acc\u00e9s als fitxers. De moment tots els accessos que hem fet als fitxers, tant binaris com de car\u00e0cter, ha estat seq\u00fcencials . Aix\u00f2 vol dir que sempre comencem pel principi del fitxer fins que arribem a la informaci\u00f3 que volem, o en la major part dels casos fins el final de fitxer. Per\u00f2, i si volem \u00fanicament una determinada informaci\u00f3? En l'exemple de l'apartat anterior, qu\u00e8 haur\u00edem de fer si volgu\u00e9rem nom\u00e9s la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia)? Doncs haur\u00edem de passar primer per tots els anteriors. Com nom\u00e9s hi ha 2 davant, no sembla molta feina, per\u00f2 \u00e9s f\u00e0cil de veure la dificultat (o millor dit el cost) si el fitxer constara de centenars o milers d'empleats. Suposem un fitxer de 10.000 empleats. Si volem accedir a l'empleat 9.500 haur\u00edem de passar pels 9.499 empleats anteriors, ja que l'acc\u00e9s seq\u00fcencial obliga a comen\u00e7ar pel principi i anar passant fins que trobem la informaci\u00f3. I encara pitjor: i si despr\u00e9s de consultar l'empleat 9.500 ara volem consultar el 9.000? Doncs haur\u00edem de comen\u00e7ar des del principi, perqu\u00e8 ja ens l'hav\u00edem passat. Afortunadament i ha una altra manera d'accedir, un altre tipus d'acc\u00e9s. S'anomena acc\u00e9s directe perqu\u00e8 permetr\u00e0 anar directament a una posici\u00f3 determinada del fitxer. Moltes vegades tamb\u00e9 es diu acc\u00e9s relatiu o acc\u00e9s aleatori , per\u00f2 el funcionament sempre \u00e9s el mateix. I mireu que estem parlant d'acc\u00e9s. Per tant el que canviar\u00e0 no \u00e9s la classe File sin\u00f3 qui permet accedir al contingut, \u00e9s a dir les classes de flux d'informaci\u00f3 (els Streams). Les classes InputStream-OutputStream i Reader-Writer nom\u00e9s permeten l'acc\u00e9s seq\u00fcencial. Per tant per a l'acc\u00e9s directe disposarem d'una altra classe que ens permetr\u00e0 fer totes les operacions, tant de lectura com d'escriptura. T\u00e9 l'avantatge que disposa de molts m\u00e8todes per a poder accedir a la informaci\u00f3. No ens fara falta, per tant, les classes \"decoradores\" que afegeixen funcionalitats. Amb aquesta classe tindrem suficient. RandomAccessFile La classe RandomAccessFile ens permetr\u00e0 accedir de forma directa a un fitxer. No ens far\u00e0 falta, en principi, cap altra classe m\u00e9s. Ens proporcionar\u00e0 tota la funcionalitat necess\u00e0ria. En els constructors aniran 2 par\u00e0metres. El primer far\u00e0 refer\u00e8ncia al fitxer. El segon al mode d'acc\u00e9s: nom\u00e9s lectura ( r ) o lectura-escriptura ( rw ). RandomAccessFile(fitxer: File, mode: String) RandomAccessFile(fitxer: String, mode: String) En el primer cas li especifiquem un File en el primer par\u00e0metre. En el segon un String que correspondr\u00e0 amb el nom del fitxer En ambd\u00f3s casos, el segon par\u00e0metre indicar\u00e0 el mode: \"r\" indica nom\u00e9s lectura \"rw\" indica lectura escriptura A pesar de ser una classe completament diferent de la jerarquia de InputStream-OutpuStream (o Readre-Writer ) implementa m\u00e8todes que es diuen exactament igual que els d'aquelles classes, cosa que fa molt m\u00e9s c\u00f2moda la utilitzaci\u00f3. Els m\u00e8todes m\u00e9s importants s\u00f3n: M\u00e8tode Explicaci\u00f3 M\u00e8tode int read() llig (escriu) un byte (encara aix\u00ed torna o se li passa un enter) void write(int) int read(byte[]) llig (escriu) un s\u00e8rie de bytes, tants com la grand\u00e0ria de l'array (si pot) int write(byte[]) byte readByte() llig (escriu) un byte interpretat com n\u00famero de 8 bits amb signe void writeByte(int) char readChar() llig (escriu) un car\u00e0cter void write(char) int readInt() llig (escriu) un enter (4 bytes) void write(int) short readShort() llig (escriu) un enter xicotet (2 bytes) void write(short) long readLong() llig (escriu) un enter llarg (8 bytes) void write(long) float readFloat() llig (escriu) un n\u00famero real en simple precisi\u00f3 (4 bytes) void write(float) double readDouble() llig (escriu) un n\u00famero real en doble precisi\u00f3 (8 bytes) void write(double) String readUTF() llig (escriu) un cadena de car\u00e0cters (interpretat com UTF-8) void writeUTF() void seek(long) situa el punter en la posici\u00f3, mesurat des del principi del fitxer long length() torna la grand\u00e0ria del fitxer void close() Tanca el flux de l'acc\u00e9s directe En cada lectura, despr\u00e9s de llegir el punter que apunta al fitxer estar\u00e0 situat despr\u00e9s de la dada llegida, siga quina siga la grand\u00e0ria. Anem a veure un exemple utilitzant el fitxer Empleats.dat creat en l'apartat anterior. Obrim l'acc\u00e9s directe \u00fanicament en mode lectura, i ens situem directament a la posici\u00f3 56, que \u00e9s on comen\u00e7a la informaci\u00f3 de l'empleada 3 (Cl\u00e0udia). Posteriorment utilitzem el m\u00e8tode de lectura apropiat per a cada tipus de dada. Copieu el codi seg\u00fcent en un fitxer de kotlin anomenat Exemple_3_2_1_EmpleatsDirecte.kt package exemples import java.io.RandomAccessFile fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats.dat\", \"r\") f.seek(56) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) f.close() } R\u00e0pidament observem una cosa: com sab\u00edem que ens hav\u00edem de situar en la posici\u00f3 56? I si els noms del dos primers hagueren sigut m\u00e9s llargs o m\u00e9s curts? Per a poder solucionar els problemes anteriors, podr\u00edem fer que els noms siguen de llarg\u00e0ria fixa. Les altres dades no donen problemes. Intentarem ara donar sempre una grand\u00e0ria de 10 car\u00e0cters a cada nom (si sospit\u00e0rem que no en tenim prou, haur\u00edem de fer-los m\u00e9s grans). Anem a crear el fitxer Empleats2.dat , i ser\u00e0 exactament igual al de l'anterior apartat, excepte que en el moment de posar els noms (en un array de strings) posem exactament 10 car\u00e0cters, omplint amb blancs si \u00e9s necessari. Evidentment, aquesta no \u00e9s l'\u00fanica manera, per\u00f2 per a les poques dades que tenim, s\u00ed la m\u00e9s r\u00e0pida. val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") La sent\u00e8ncia anterior \u00e9s l'\u00fanica difer\u00e8ncia respecte al programa de creaci\u00f3 d'Empleats.dat de la pregunta anterior, a banda del nom del fitxer, que ara ser\u00e0 Empleat2.dat :. Copieu el seg\u00fcent codi en el fitxer Kotlin: Exemple_3_2_2_Crear_Empleats2.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats2.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeUTF(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Ara que sabem la grand\u00e0ria exacta del nom, podem saber que la informaci\u00f3 de cada empleat \u00e9s: N\u00famero d'empleat (enter) 4 bytes Nom (10 car\u00e0cters + 2 bytes) 10 + 2 bytes Departament (enter) 4 bytes Edat (enter) 4 bytes Sou (doble precisi\u00f3) 8 bytes **Total: ** **32 bytes ** Sabent que cada registre (la informaci\u00f3 de cada empleat) ocupa 32 bytes, sembla f\u00e0cil anar a un determinat empleat. Per a poder provar-lo b\u00e9, introduirem el n\u00famero d'empleat per teclat, fins introduir 0. Observeu que si s'introdueix 1, hem d'anar a pel primer registre, que est\u00e0 a principi de fitxer. Si introdu\u00efm 2, anem a pel segon, que nom\u00e9s en t\u00e9 un davant, per tant 32 bytes. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_3_Empleats2Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats2.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt () while (num != -1) { f.seek(32 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) println(\"Nom: \" + f.readUTF()) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } El problema ara tamb\u00e9 sembla obvi. Hem assumit que cada car\u00e0cter ocupa un byte. Com es codificar\u00e0 en UTF-8, mentre siguen car\u00e0cters normals aix\u00ed ser\u00e0. Per\u00f2 qu\u00e8 passar\u00e0 quan hi haja un car\u00e0cter accentuat? Que ocupar\u00e0 2 car\u00e0cters. Aix\u00ed, com Cl\u00e0udia t\u00e9 un d'aquestos car\u00e0cters, la cadena no ocupar\u00e0 10+2 = 12 bytes, sin\u00f3 13. Aleshores, si intentem anar al quart empleat, ens donar\u00e0 problemes. La manera de solucionar-lo ser\u00e0 escriure de manera que tots els car\u00e0cters ocupen sempre el mateix. Hi ha un m\u00e8tode que ens ho permet: writeChars . Guardar\u00e0 cada car\u00e0cter amb dos bytes, i no es guardar\u00e0 la llarg\u00e0ria de la cadena. Podem intentar utilitzar-lo per construir el fitxer Empleats3.dat . Nom\u00e9s haurem de substituir la seg\u00fcent sent\u00e8ncia: f.writeChars(noms[i]) a banda del nom del fitxer, clar. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_2_4_CrearEmpleat3.kt package exemples import java.io.DataOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = DataOutputStream(FileOutputStream(\"Empleats3.dat\")) val noms = arrayOf(\"Andreu \",\"Bernat \",\"Cl\u00e0udia \",\"Dami\u00e0 \") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0 ) for (i in 0..3){ f.writeInt(i + 1) f.writeChars(noms[i]) f.writeInt(departaments[i]) f.writeInt(edats[i]) f.writeDouble(sous[i]) } f.close() println(\"Fitxer creat\") } Lamentablement la lectura no \u00e9s tan f\u00e0cil. Haurem de llegir exactament 10 car\u00e0cters (podr\u00edem utilitzar algun altre m\u00e8tode, per\u00f2 el que es mostra permet identificar clarament que es llegiran 10 car\u00e0cters). Els anirem acumulant en un String poder mostrar-lo. Recordeu tamb\u00e9 que ara el nom ocupa 20 bytes, que sumats als altres 20 de les altres dades fan un total de 40 bytes per registre. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_2_5_Empleats3Directe.kt : package exemples import java.io.RandomAccessFile import java.util.Scanner fun main(args: Array<String>) { val f = RandomAccessFile(\"Empleats3.dat\", \"rw\") val sc = Scanner(System.`in`) println(\"Quin registre? (-1 per a eixir): \") var num = sc.nextInt() while (num != -1) { f.seek(40 * (num - 1).toLong()) println(\"N\u00fam.: \" + f.readInt()) var nom = \"\" for (i in 1..10) nom += f.readChar() println(\"Nom: \" + nom) println(\"Depart: \" + f.readInt()) println(\"Edat: \" + f.readInt()) println(\"Sou: \" + f.readDouble()) println() println(\"Quin registre? (-1 per a eixir): \") num = sc.nextInt() } f.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.- Acc\u00e9s directe a fitxers"},{"location":"AD_T3_Fitxers_de_diferents_formats/3_seriaci_dobjectes/","text":"Acc\u00e9s a Dades 3.- Seriaci\u00f3 d'objectes Seriaci\u00f3 d'objectes La t\u00e8cnica de la seriaci\u00f3 \u00e9s segurament la m\u00e9s senzilla de totes, per\u00f2 tamb\u00e9 a la vegada la m\u00e9s problem\u00e0tica. Java, i per tant tamb\u00e9 Kotlin, disposa d\u2019un sistema gen\u00e8ric de seriaci\u00f3 de qualsevol objecte, un sistema recursiu que es repeteix per cada objecte contingut a la inst\u00e0ncia que s\u2019est\u00e0 seriant. Aquest proc\u00e9s para en arribar als tipus primitius, els quals es guarden com una s\u00e8rie de bytes. A banda dels tipus primitius, Java serialitza tamb\u00e9 molta informaci\u00f3 addicional o metadades espec\u00edfiques de cada classe (el nom de les classe, els noms dels atributs i molta m\u00e9s informaci\u00f3 addicional). Gr\u00e0cies a les metadades es fa possible automatitzar la seriaci\u00f3 de forma gen\u00e8rica amb garanties de recuperar un objecte tal com es va guardar . Lamentablement, aquest \u00e9s un procediment espec\u00edfic de Java . \u00c9s a dir, no \u00e9s possible recuperar els objectes seriats des de Java utilitzant un altre llenguatge. D\u2019altra banda, el fet de guardar metadades pot arribar a comportar tamb\u00e9 problemes, encara que utilitzem sempre el llenguatge Java. La modificaci\u00f3 d\u2019una classe pot fer variar les seues metadades. Aquestes variacions poden donar problemes de recuperaci\u00f3 d\u2019inst\u00e0ncies que hagen estat guardades amb algunes versions anteriors a la modificaci\u00f3, impedint que l\u2019objecte puga ser recuperat. Aquestes consideracions fa que no siga pr\u00e0ctica aquesta t\u00e8cnica per guardar objectes de forma m\u00e9s o menys permanent. En canvi, la seua senzillesa la fa una perfecta candidata per a l\u2019emmagatzematge temporal, per exemple dins de la mateixa sessi\u00f3. Per a que un objecte puga ser seriat cal que la seua classe i tot el seu contingut implementen la interf\u00edcie Serializable . Es tracta d\u2019una interf\u00edcie sense m\u00e8todes, perqu\u00e8 l\u2019\u00fanic objectiu de la interf\u00edcie \u00e9s actuar de marcador per indicar a la m\u00e0quina virtual quines classes es poden seriar i quines no. Totes les classes equivalents als tipus b\u00e0sics ja implementen Serializable. Tamb\u00e9 implementen aquesta interf\u00edcie la classe String i tots els contenidors i els objectes Array. La seriaci\u00f3 de col\u00b7leccions dep\u00e8n en \u00faltim terme dels elements continguts. Si aquestos s\u00f3n seriables, la col\u00b7lecci\u00f3 tamb\u00e9 ho ser\u00e0. En cas que la classe de l\u2019objecte que s\u2019intente seriar, o les d\u2019algun dels objectes que continga, no implementaren la interf\u00edcie Serializable, es llan\u00e7aria una excepci\u00f3 de tipus NotSerializableException , impedint l\u2019emmagatzematge. Els Streams ObjectInputStream i ObjectOutputStream s\u00f3n decoradors que afegeixen a qualsevol altre Stream la capacitat de seriar qualsevol objecte Serializable. El stream d'eixida disposar\u00e0 del m\u00e8tode writeObject . i el stream d\u2019entrada, el m\u00e8tode de lectura readObject . El m\u00e8tode readObject nom\u00e9s permet recuperar inst\u00e0ncies que siguen de la mateixa classe que la que es va guardar. En cas contrari, es llan\u00e7aria una excepci\u00f3 de tipus ClassCastExeception . A m\u00e9s, cal que l\u2019aplicaci\u00f3 dispose del codi compilat de la classe; si no f\u00f3ra aix\u00ed, l\u2019excepci\u00f3 llan\u00e7ada seria ClassNotFoundException . Exemple Ens recolzarem en un exemple utilitzat en els anteriors punts, en els empleats. Ara anem a suposar que els empleats s\u00f3n objectes, i intentarem guardar aquestos objectes en un fitxer amb una seriaci\u00f3. El primer pas ser\u00e0 construir la classe Empleat , que contindr\u00e0 la mateixa informaci\u00f3 que en els altres apartats: n\u00famero d'empleat, nom, departament, edat i sou. package exemples import java.io.Serializable class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double): Serializable Anem a intentar construir el fitxer de dades amb els objectes guardats. El flux de dades ser\u00e0 un ObjectOutputStream per a poder escriure ( writeObject ). I observeu com s'ha de recolzar en un OutputStream, que en aquest cas ser\u00e0 d'un fitxer, \u00e9s a dir un FileOutputStream . A cada iteraci\u00f3 del bucle senzillament construirem un objecte de la classe Empleat i l'escriurem al fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_3_1_GuardarObjectes.kt import java.io.ObjectOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = ObjectOutputStream(FileOutputStream(\"Empleats.obj\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) for (i in 0..3){ val e = Empleat (i + 1, noms[i], departaments[i], edats[i], sous[i]) f.writeObject(e) } f.close(); } Nota El fitxer creat, Empleats.obj , evidentment no \u00e9s de text. Tanmateix si l'obrim amb un editor de text podrem veure alguna cosa. La primera q\u00fcesti\u00f3 \u00e9s que es guarda el nom de la classe amb el nom del paquet davant. exemples.Empleat \u00e9s realment el nom de la classe creada. Es guarden tamb\u00e9 els noms dels camps. Tot aix\u00f2 s\u00f3n les metadades que hav\u00edem comentat, i que permeten la recuperaci\u00f3 posterior dels objectes guardats I despr\u00e9s ja podem veure la informaci\u00f3 guardada, on identifiquem els noms dels empleats Per a llegir el fitxer creat, Empleats.obj , utilitzarem el ObjectInputStream per a poder fer readObject . S'ha de basar en un InputStream, que en aquest cas ser\u00e0 un FileInputStream . Lamentablement el m\u00e8tode available() no funcionar\u00e0 correctament, i no ens dir\u00e0 realment els bytes que queden per llegir. El tractament de final de fitxer el farem capturant l'excepci\u00f3 (l'error) d'haver arribat al final i intentat llegir encara: EOFException . La ra\u00f3 \u00e9s que readObject no torna null, a no ser que s'haja introdu\u00eft aquest valor. Per tant muntem un bucle infinit, per\u00f2 capturant amb try ... catch l'error, que \u00e9s quan tancarem el Stream. Copieu el seg\u00fcent codi a un fitxer Kotlin anomenat Exemple_3_3_2_LlegirObjectes.kt package exemples import java.io.ObjectInputStream import java.io.FileInputStream import java.io.EOFException fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream(\"Empleats.obj\")) try { while (true) { val e = f.readObject() as Empleat println(\"N\u00famero: \" + e.num) println(\"Nom: \" + e.nom) println(\"Departament: \" + e.departament) println(\"Edat: \" + e.edat) println(\"Sou: \" + e.sou) println(); } } catch (eof: EOFException) { f.close() } } Nota En realitat, en el fitxer es guarda, a m\u00e9s del nom del paquet i el nom de la classe, l'identificador de la classe: el serialVersionUID , per a poder identificar un\u00edvocament la classe. Aix\u00f2 ens pot donar problemes si intentem compartir la informaci\u00f3 entre nosaltres, ja que perfectament ens pot generar UID diferents. Per a evitar-lo podr\u00edem definir nosaltres aquest serialVersionUID , i aleshores no hi haur\u00e0 problemes per a compartir. Fins i tot serviria per a poder compartir el fitxer d'objectes entre Kotlin i Java package exemples import java.io.Serializable class Empleat (var num: Int,var nom: String,var departament: Int,var edat: Int,var sou: Double): Serializable { companion object { private const val serialVersionUID: Long = 1 } } Si fem aquest canvi en la classe Empleat haurem de tornar a generar el fitxer ( Exemple_3_3_1_GuardarObjectes.kt ) abans de poder consultar-lo ( Exemple_3_3_2_LlegirObjectes.kt ), perqu\u00e8 a tots els efectes seria una classe nova. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Seriaci\u00f3 d'objectes"},{"location":"AD_T3_Fitxers_de_diferents_formats/3_seriaci_dobjectes/#3-seriacio-dobjectes","text":"Seriaci\u00f3 d'objectes La t\u00e8cnica de la seriaci\u00f3 \u00e9s segurament la m\u00e9s senzilla de totes, per\u00f2 tamb\u00e9 a la vegada la m\u00e9s problem\u00e0tica. Java, i per tant tamb\u00e9 Kotlin, disposa d\u2019un sistema gen\u00e8ric de seriaci\u00f3 de qualsevol objecte, un sistema recursiu que es repeteix per cada objecte contingut a la inst\u00e0ncia que s\u2019est\u00e0 seriant. Aquest proc\u00e9s para en arribar als tipus primitius, els quals es guarden com una s\u00e8rie de bytes. A banda dels tipus primitius, Java serialitza tamb\u00e9 molta informaci\u00f3 addicional o metadades espec\u00edfiques de cada classe (el nom de les classe, els noms dels atributs i molta m\u00e9s informaci\u00f3 addicional). Gr\u00e0cies a les metadades es fa possible automatitzar la seriaci\u00f3 de forma gen\u00e8rica amb garanties de recuperar un objecte tal com es va guardar . Lamentablement, aquest \u00e9s un procediment espec\u00edfic de Java . \u00c9s a dir, no \u00e9s possible recuperar els objectes seriats des de Java utilitzant un altre llenguatge. D\u2019altra banda, el fet de guardar metadades pot arribar a comportar tamb\u00e9 problemes, encara que utilitzem sempre el llenguatge Java. La modificaci\u00f3 d\u2019una classe pot fer variar les seues metadades. Aquestes variacions poden donar problemes de recuperaci\u00f3 d\u2019inst\u00e0ncies que hagen estat guardades amb algunes versions anteriors a la modificaci\u00f3, impedint que l\u2019objecte puga ser recuperat. Aquestes consideracions fa que no siga pr\u00e0ctica aquesta t\u00e8cnica per guardar objectes de forma m\u00e9s o menys permanent. En canvi, la seua senzillesa la fa una perfecta candidata per a l\u2019emmagatzematge temporal, per exemple dins de la mateixa sessi\u00f3. Per a que un objecte puga ser seriat cal que la seua classe i tot el seu contingut implementen la interf\u00edcie Serializable . Es tracta d\u2019una interf\u00edcie sense m\u00e8todes, perqu\u00e8 l\u2019\u00fanic objectiu de la interf\u00edcie \u00e9s actuar de marcador per indicar a la m\u00e0quina virtual quines classes es poden seriar i quines no. Totes les classes equivalents als tipus b\u00e0sics ja implementen Serializable. Tamb\u00e9 implementen aquesta interf\u00edcie la classe String i tots els contenidors i els objectes Array. La seriaci\u00f3 de col\u00b7leccions dep\u00e8n en \u00faltim terme dels elements continguts. Si aquestos s\u00f3n seriables, la col\u00b7lecci\u00f3 tamb\u00e9 ho ser\u00e0. En cas que la classe de l\u2019objecte que s\u2019intente seriar, o les d\u2019algun dels objectes que continga, no implementaren la interf\u00edcie Serializable, es llan\u00e7aria una excepci\u00f3 de tipus NotSerializableException , impedint l\u2019emmagatzematge. Els Streams ObjectInputStream i ObjectOutputStream s\u00f3n decoradors que afegeixen a qualsevol altre Stream la capacitat de seriar qualsevol objecte Serializable. El stream d'eixida disposar\u00e0 del m\u00e8tode writeObject . i el stream d\u2019entrada, el m\u00e8tode de lectura readObject . El m\u00e8tode readObject nom\u00e9s permet recuperar inst\u00e0ncies que siguen de la mateixa classe que la que es va guardar. En cas contrari, es llan\u00e7aria una excepci\u00f3 de tipus ClassCastExeception . A m\u00e9s, cal que l\u2019aplicaci\u00f3 dispose del codi compilat de la classe; si no f\u00f3ra aix\u00ed, l\u2019excepci\u00f3 llan\u00e7ada seria ClassNotFoundException . Exemple Ens recolzarem en un exemple utilitzat en els anteriors punts, en els empleats. Ara anem a suposar que els empleats s\u00f3n objectes, i intentarem guardar aquestos objectes en un fitxer amb una seriaci\u00f3. El primer pas ser\u00e0 construir la classe Empleat , que contindr\u00e0 la mateixa informaci\u00f3 que en els altres apartats: n\u00famero d'empleat, nom, departament, edat i sou. package exemples import java.io.Serializable class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double): Serializable Anem a intentar construir el fitxer de dades amb els objectes guardats. El flux de dades ser\u00e0 un ObjectOutputStream per a poder escriure ( writeObject ). I observeu com s'ha de recolzar en un OutputStream, que en aquest cas ser\u00e0 d'un fitxer, \u00e9s a dir un FileOutputStream . A cada iteraci\u00f3 del bucle senzillament construirem un objecte de la classe Empleat i l'escriurem al fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_3_1_GuardarObjectes.kt import java.io.ObjectOutputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f = ObjectOutputStream(FileOutputStream(\"Empleats.obj\")) val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) for (i in 0..3){ val e = Empleat (i + 1, noms[i], departaments[i], edats[i], sous[i]) f.writeObject(e) } f.close(); } Nota El fitxer creat, Empleats.obj , evidentment no \u00e9s de text. Tanmateix si l'obrim amb un editor de text podrem veure alguna cosa. La primera q\u00fcesti\u00f3 \u00e9s que es guarda el nom de la classe amb el nom del paquet davant. exemples.Empleat \u00e9s realment el nom de la classe creada. Es guarden tamb\u00e9 els noms dels camps. Tot aix\u00f2 s\u00f3n les metadades que hav\u00edem comentat, i que permeten la recuperaci\u00f3 posterior dels objectes guardats I despr\u00e9s ja podem veure la informaci\u00f3 guardada, on identifiquem els noms dels empleats Per a llegir el fitxer creat, Empleats.obj , utilitzarem el ObjectInputStream per a poder fer readObject . S'ha de basar en un InputStream, que en aquest cas ser\u00e0 un FileInputStream . Lamentablement el m\u00e8tode available() no funcionar\u00e0 correctament, i no ens dir\u00e0 realment els bytes que queden per llegir. El tractament de final de fitxer el farem capturant l'excepci\u00f3 (l'error) d'haver arribat al final i intentat llegir encara: EOFException . La ra\u00f3 \u00e9s que readObject no torna null, a no ser que s'haja introdu\u00eft aquest valor. Per tant muntem un bucle infinit, per\u00f2 capturant amb try ... catch l'error, que \u00e9s quan tancarem el Stream. Copieu el seg\u00fcent codi a un fitxer Kotlin anomenat Exemple_3_3_2_LlegirObjectes.kt package exemples import java.io.ObjectInputStream import java.io.FileInputStream import java.io.EOFException fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream(\"Empleats.obj\")) try { while (true) { val e = f.readObject() as Empleat println(\"N\u00famero: \" + e.num) println(\"Nom: \" + e.nom) println(\"Departament: \" + e.departament) println(\"Edat: \" + e.edat) println(\"Sou: \" + e.sou) println(); } } catch (eof: EOFException) { f.close() } } Nota En realitat, en el fitxer es guarda, a m\u00e9s del nom del paquet i el nom de la classe, l'identificador de la classe: el serialVersionUID , per a poder identificar un\u00edvocament la classe. Aix\u00f2 ens pot donar problemes si intentem compartir la informaci\u00f3 entre nosaltres, ja que perfectament ens pot generar UID diferents. Per a evitar-lo podr\u00edem definir nosaltres aquest serialVersionUID , i aleshores no hi haur\u00e0 problemes per a compartir. Fins i tot serviria per a poder compartir el fitxer d'objectes entre Kotlin i Java package exemples import java.io.Serializable class Empleat (var num: Int,var nom: String,var departament: Int,var edat: Int,var sou: Double): Serializable { companion object { private const val serialVersionUID: Long = 1 } } Si fem aquest canvi en la classe Empleat haurem de tornar a generar el fitxer ( Exemple_3_3_1_GuardarObjectes.kt ) abans de poder consultar-lo ( Exemple_3_3_2_LlegirObjectes.kt ), perqu\u00e8 a tots els efectes seria una classe nova. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Seriaci\u00f3 d'objectes"},{"location":"AD_T3_Fitxers_de_diferents_formats/41__parser_o_analitzador_xml/","text":"Acc\u00e9s a Dades 4.1 - Parser o analitzador XML Un Parser XML \u00e9s una classe que ens permet analitzar i classificar el contingut d\u2019un arxiu XML extraient la informaci\u00f3 continguda en cada una de les etiquetes, i relacionar-la d\u2019acord amb la seua posici\u00f3 dins la jerarquia. Hi ha dos tipus d'analitzadors depenent de la manera de funcionar. Analitzadors seq\u00fcencials Els analitzadors seq\u00fcencials permeten extreure el contingut a mida que es van descobrint les etiquetes d\u2019obertura i tancament. Tamb\u00e9 s\u2019anomenen analitzadors sint\u00e0ctics . S\u00f3n analitzadors molt r\u00e0pids, per\u00f2 presenten el problema que cada vegada que es necessita accedir a una part del contingut, s'ha de rellegir tot el document de dalt a baix. En Java, l\u2019analitzador sint\u00e0ctic m\u00e9s popular s\u2019anomena SAX , que vol dir Simple API for XML . \u00c9s una analitzador molt utilitzat en diverses biblioteques de tractament de dades XML, per\u00f2 no sol utilitzar-se en aplicacions finals, pel problema abans comentat d'haver de llegir-se tot el document XML a cada consulta. Per aquesta ra\u00f3 no els veurem en aquest curs. Analitzadors jer\u00e0rquics Generalment, les aplicacions finals que han de treballar amb dades XML solen utilitzar analitzadors jer\u00e0rquics. Els analitzadors jer\u00e0rquics guarden totes les dades del document XML en mem\u00f2ria dins una estructura jer\u00e0rquica, a mida que van analitzant el seu contingut. I per aix\u00f2 s\u00f3n ideals per a aplicacions que requereixen una consulta cont\u00ednua de les dades. El format de l\u2019estructura on es guarda la informaci\u00f3 en mem\u00f2ria ha estat especificat per l\u2019organisme internacional W3C (World Wide Web Consortium) i es coneix com a DOM ( Document Object Model ). \u00c9s una estructura que HTML i javascript han popularitzat molt i es tracta d\u2019una especificaci\u00f3 que Java materialitza en forma d\u2019interf\u00edcies. La principal s\u2019anomena Document i representa tot un document XML. En tractar-se d\u2019una interf\u00edcie, pot ser implementada per diverses classes. L\u2019est\u00e0ndard W3C defineix la classe DocumentBuilder (constructor de documents) per a poder crear estructures DOM a partir d\u2019un XML. Aquesta classe DocumentBuilder \u00e9s una classe abstracta, i per tal que es puga adaptar a les diferents plataformes, pot necessitar fonts de dades o requeriments diversos. Recordeu que les classes abstractes no es poden instanciar de forma directa. Per aquest motiu, el consorci W3 especifica tamb\u00e9 la classe DocumentBuilderFactory , \u00e9s a dir, el fabricador de DocumentBuilder . Les llibreries des d'on importarem les classes comentades s\u00f3n: DocumentBuilderFactory i DocumentBuilder les importarem de la llibreria javax.xml.parsers. * Document l'importarem de org.w3c.dom. * Hem de cuidar sobretot aquesta \u00faltima importaci\u00f3, perqu\u00e8 per defecte Java ens ofereix moltes llibreries des d'on importar Document . I si no la importem de la llibreria correcta, evidentment despr\u00e9s tindrem errors. Les instruccions necess\u00e0ries per llegir un fitxer XML i crear un objecte Document serien les seg\u00fcents: import java.io.FileInputStream import javax.xml.parsers.DocumentBuilder import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val dbFactory = DocumentBuilderFactory.newInstance() val dBuilder = dbFactory.newDocumentBuilder() val doc = dBuilder.parse(File(\u201cfitxer.xml\u201d)) Tornem a insistir en la necessitat d'importar Document de la llibreria org.w3c.dom. * Anem a basar-nos en un exemple per poder veure a poc a poc la manera d'utilitzar el parser. \u00c9s un exemple que possiblement es va veure en primer, en el m\u00f2dul de Llenguatge de Marques. Suposarem que est\u00e0 en el fitxer cotxes.xml , i que est\u00e0 en el directori del projecte on farem les proves. ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg El primer que farem ser\u00e0 intentar connectar amb aquest fitxer, per\u00f2 d'una forma un poc m\u00e9s redu\u00efda que abans, sense definir objectes del DocumentBuilderFactory ni DocumentBuilder . Tampoc ens caldr\u00e0 definir- nos el File ( FileInputStream ) ja que el m\u00e8tode parse tamb\u00e9 agafa un String com a par\u00e0metre: import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") Per\u00f2, i si el proc\u00e9s que necessitem \u00e9s l'invers? \u00c9s a dir, i si el que volem \u00e9s guardar una estructura DOM en un fitxer XML? En aquest cas el que haurem de fer ser\u00e0 construir un document buit , anar posant els elements i atributs (amb els seus valors) d'alguna manera, i posteriorment guardar-lo en un fitxer. Deixem per a un poc m\u00e9s avant com anar construint els nodes del document i centrem-nos en el fet de crear el document buit i guardar-lo en un fitxer. Podem construir un document nou a partir del DocumentBuilder , utilitzant el m\u00e8tode newDocument() : import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc1 = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument() Per a escriure la informaci\u00f3 continguda al DOM a un fitxer, es pot fer utilitzant una altra utilitat de Java anomenada Transformer . Es tracta d\u2019una utilitat que permet realitzar f\u00e0cilment conversions entre diferents representacions d\u2019informaci\u00f3 jer\u00e0rquica. \u00c9s capa\u00e7, per exemple, de passar la informaci\u00f3 continguda en un objecte Document a un fitxer de text en format XML . Tamb\u00e9 seria capa\u00e7 de fer l\u2019operaci\u00f3 inversa, per\u00f2 no val la pena perqu\u00e8 el mateix DocumentBuilder ja s\u2019encarrega d\u2019aix\u00f2. Transformer \u00e9s tamb\u00e9 una classe abstracta i requereix d\u2019una factory per poder ser instanciada. La classe Transformer pot treballar amb multitud de contenidors d\u2019informaci\u00f3 perqu\u00e8 en realitat treballa amb un parell de tipus adaptadors (classes que fan compatibles jerarquies diferents) que s\u2019anomenen Source i Result . Les classes que implementen aquestes interf\u00edcies s\u2019encarregaran de fer compatible un tipus de contenidor espec\u00edfic al requeriment de la classe Transformer . Aix\u00ed, disposem de les classes DOMSource , SAXSource o StreamSource com a adaptadors del contenidor de la font d\u2019informaci\u00f3 (DOM, SAX o Stream respectivament). DOMResult , SAXResult o StreamResult s\u00f3n els adaptadors equivalents del contenidor dest\u00ed. A nosaltres ara, com que volem passar un document DOM a un fitxer, ens convindr\u00e0 un DOMSource i un StreamResult El codi b\u00e0sic per realitzar una transformaci\u00f3 de DOM a fitxer de text XML seria el seg\u00fcent: val trans = TransformerFactory.newInstance().newTransformer() val source = DOMSource(doc) val result = StreamResult(file) trans.transform(source, result) De tota manera, veurem m\u00e9s avant un exemple on ens guardarem una estructura DOM en un fitxer XML. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.1 - Parser o analitzador XML"},{"location":"AD_T3_Fitxers_de_diferents_formats/41__parser_o_analitzador_xml/#41-parser-o-analitzador-xml","text":"Un Parser XML \u00e9s una classe que ens permet analitzar i classificar el contingut d\u2019un arxiu XML extraient la informaci\u00f3 continguda en cada una de les etiquetes, i relacionar-la d\u2019acord amb la seua posici\u00f3 dins la jerarquia. Hi ha dos tipus d'analitzadors depenent de la manera de funcionar. Analitzadors seq\u00fcencials Els analitzadors seq\u00fcencials permeten extreure el contingut a mida que es van descobrint les etiquetes d\u2019obertura i tancament. Tamb\u00e9 s\u2019anomenen analitzadors sint\u00e0ctics . S\u00f3n analitzadors molt r\u00e0pids, per\u00f2 presenten el problema que cada vegada que es necessita accedir a una part del contingut, s'ha de rellegir tot el document de dalt a baix. En Java, l\u2019analitzador sint\u00e0ctic m\u00e9s popular s\u2019anomena SAX , que vol dir Simple API for XML . \u00c9s una analitzador molt utilitzat en diverses biblioteques de tractament de dades XML, per\u00f2 no sol utilitzar-se en aplicacions finals, pel problema abans comentat d'haver de llegir-se tot el document XML a cada consulta. Per aquesta ra\u00f3 no els veurem en aquest curs. Analitzadors jer\u00e0rquics Generalment, les aplicacions finals que han de treballar amb dades XML solen utilitzar analitzadors jer\u00e0rquics. Els analitzadors jer\u00e0rquics guarden totes les dades del document XML en mem\u00f2ria dins una estructura jer\u00e0rquica, a mida que van analitzant el seu contingut. I per aix\u00f2 s\u00f3n ideals per a aplicacions que requereixen una consulta cont\u00ednua de les dades. El format de l\u2019estructura on es guarda la informaci\u00f3 en mem\u00f2ria ha estat especificat per l\u2019organisme internacional W3C (World Wide Web Consortium) i es coneix com a DOM ( Document Object Model ). \u00c9s una estructura que HTML i javascript han popularitzat molt i es tracta d\u2019una especificaci\u00f3 que Java materialitza en forma d\u2019interf\u00edcies. La principal s\u2019anomena Document i representa tot un document XML. En tractar-se d\u2019una interf\u00edcie, pot ser implementada per diverses classes. L\u2019est\u00e0ndard W3C defineix la classe DocumentBuilder (constructor de documents) per a poder crear estructures DOM a partir d\u2019un XML. Aquesta classe DocumentBuilder \u00e9s una classe abstracta, i per tal que es puga adaptar a les diferents plataformes, pot necessitar fonts de dades o requeriments diversos. Recordeu que les classes abstractes no es poden instanciar de forma directa. Per aquest motiu, el consorci W3 especifica tamb\u00e9 la classe DocumentBuilderFactory , \u00e9s a dir, el fabricador de DocumentBuilder . Les llibreries des d'on importarem les classes comentades s\u00f3n: DocumentBuilderFactory i DocumentBuilder les importarem de la llibreria javax.xml.parsers. * Document l'importarem de org.w3c.dom. * Hem de cuidar sobretot aquesta \u00faltima importaci\u00f3, perqu\u00e8 per defecte Java ens ofereix moltes llibreries des d'on importar Document . I si no la importem de la llibreria correcta, evidentment despr\u00e9s tindrem errors. Les instruccions necess\u00e0ries per llegir un fitxer XML i crear un objecte Document serien les seg\u00fcents: import java.io.FileInputStream import javax.xml.parsers.DocumentBuilder import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val dbFactory = DocumentBuilderFactory.newInstance() val dBuilder = dbFactory.newDocumentBuilder() val doc = dBuilder.parse(File(\u201cfitxer.xml\u201d)) Tornem a insistir en la necessitat d'importar Document de la llibreria org.w3c.dom. * Anem a basar-nos en un exemple per poder veure a poc a poc la manera d'utilitzar el parser. \u00c9s un exemple que possiblement es va veure en primer, en el m\u00f2dul de Llenguatge de Marques. Suposarem que est\u00e0 en el fitxer cotxes.xml , i que est\u00e0 en el directori del projecte on farem les proves. ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg El primer que farem ser\u00e0 intentar connectar amb aquest fitxer, per\u00f2 d'una forma un poc m\u00e9s redu\u00efda que abans, sense definir objectes del DocumentBuilderFactory ni DocumentBuilder . Tampoc ens caldr\u00e0 definir- nos el File ( FileInputStream ) ja que el m\u00e8tode parse tamb\u00e9 agafa un String com a par\u00e0metre: import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") Per\u00f2, i si el proc\u00e9s que necessitem \u00e9s l'invers? \u00c9s a dir, i si el que volem \u00e9s guardar una estructura DOM en un fitxer XML? En aquest cas el que haurem de fer ser\u00e0 construir un document buit , anar posant els elements i atributs (amb els seus valors) d'alguna manera, i posteriorment guardar-lo en un fitxer. Deixem per a un poc m\u00e9s avant com anar construint els nodes del document i centrem-nos en el fet de crear el document buit i guardar-lo en un fitxer. Podem construir un document nou a partir del DocumentBuilder , utilitzant el m\u00e8tode newDocument() : import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Document ... val doc1 = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument() Per a escriure la informaci\u00f3 continguda al DOM a un fitxer, es pot fer utilitzant una altra utilitat de Java anomenada Transformer . Es tracta d\u2019una utilitat que permet realitzar f\u00e0cilment conversions entre diferents representacions d\u2019informaci\u00f3 jer\u00e0rquica. \u00c9s capa\u00e7, per exemple, de passar la informaci\u00f3 continguda en un objecte Document a un fitxer de text en format XML . Tamb\u00e9 seria capa\u00e7 de fer l\u2019operaci\u00f3 inversa, per\u00f2 no val la pena perqu\u00e8 el mateix DocumentBuilder ja s\u2019encarrega d\u2019aix\u00f2. Transformer \u00e9s tamb\u00e9 una classe abstracta i requereix d\u2019una factory per poder ser instanciada. La classe Transformer pot treballar amb multitud de contenidors d\u2019informaci\u00f3 perqu\u00e8 en realitat treballa amb un parell de tipus adaptadors (classes que fan compatibles jerarquies diferents) que s\u2019anomenen Source i Result . Les classes que implementen aquestes interf\u00edcies s\u2019encarregaran de fer compatible un tipus de contenidor espec\u00edfic al requeriment de la classe Transformer . Aix\u00ed, disposem de les classes DOMSource , SAXSource o StreamSource com a adaptadors del contenidor de la font d\u2019informaci\u00f3 (DOM, SAX o Stream respectivament). DOMResult , SAXResult o StreamResult s\u00f3n els adaptadors equivalents del contenidor dest\u00ed. A nosaltres ara, com que volem passar un document DOM a un fitxer, ens convindr\u00e0 un DOMSource i un StreamResult El codi b\u00e0sic per realitzar una transformaci\u00f3 de DOM a fitxer de text XML seria el seg\u00fcent: val trans = TransformerFactory.newInstance().newTransformer() val source = DOMSource(doc) val result = StreamResult(file) trans.transform(source, result) De tota manera, veurem m\u00e9s avant un exemple on ens guardarem una estructura DOM en un fitxer XML. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.1 - Parser o analitzador XML"},{"location":"AD_T3_Fitxers_de_diferents_formats/421_lectura/","text":"Acc\u00e9s a Dades 4.2.1 Lectura Anem a fer proves per poder comprovar el funcionament. Ens basem en el document cotxes.xml esmentat en la pregunta 4.1 Nota Aneu amb compte, perqu\u00e8 en el document cotxes.xml davant de la primera etiqueta no pot haver ni retorn de carro ni un espai en blanc ni res Coieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_1_XMLMirar.kt package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>){ val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") println(doc.getNodeName()) // torna el nom del document. No \u00e9s l'element arrel. Ens dir\u00e0 #document val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel println(arrel.getNodeName()) // torna el nom de l'element. Ens dir\u00e0 oferta println(arrel.getNodeValue()) // torna el valor de l'element. Com \u00e9s un element que cont\u00e9 altres elements, el valor \u00e9s null } Tal i com est\u00e0 documentat, aquesta ser\u00e0 l'eixida: document oferta null Anem a comprovar ara que el primer fill de oferta no \u00e9s vehiculo sin\u00f3 el retorn de carro. Els element vehiculo s\u00f3n el segon i el quart (\u00edndex 1 i 3). Copieu el seg\u00fcent codi enun fitxer Kotlin anomenat Exemple_3_4_2_XMLMirar2.kt **** package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val fills = arrel.getChildNodes() println(fills.item(0).getNodeName()) // el primer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(1).getNodeName()) // el segon fill s\u00ed que \u00e9s vehiculo println(fills.item(2).getNodeName()) // el tercer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(3).getNodeName()) // el quart fill s\u00ed que \u00e9s vehiculo println(fills.item(4).getNodeName()) // el cinqu\u00e8 fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(5).getNodeName()) // no existeix el sis\u00e8 fill. Donar\u00e0 error } Observeu que en l'\u00faltima sent\u00e8ncia estem provocant un error: text vehiculo text vehiculo text Exception in thread \"main\" java.lang.NullPointerException at exemples.Exemple_4_2_MirarXML2.main(Exemple_4_2_MirarXML2.kt:15) Per tant, hem d'anar molt en compte amb els retorns de carro . Per a poder esquivar els retorn de carro podr\u00edem mirar el tipus de cada node ( getNodeType() ), menysprear els els de tipus TEXT_NODE i considerar nom\u00e9s els de tipus ELEMENT_NODE . Per\u00f2 normalment l'acc\u00e9s que farem ser\u00e0 un poc m\u00e9s directe i m\u00e9s f\u00e0cil. Agafarem la llista de tots els element que tinguen un determinat nom amb getElementsByTagName( nom ) . * Evidentment en la llista no estaran els retorns de carro * i aix\u00ed no tindrem problemes amb ells. En el seg\u00fcent exemple recorrerem tots els element vehiculo . De cadascun agafarem el contingut dels elements marca i matricula . Tamb\u00e9 agafem el contingut de l'atribut combustible de l'element motor . Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_3_XMLMirarCotxes.kt : package exemples import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Element fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val llista = arrel.getElementsByTagName(\"vehiculo\") for (i in 0 until llista.getLength()) { val el = llista.item(i) as Element println(el.getNodeName() + \" \" + (i + 1)) println(\"Marca: \" + el.getElementsByTagName(\"marca\").item(0).getChildNodes().item(0).getNodeValue()) println(\"Matr\u00edcula: \" + el.getElementsByTagName(\"matricula\").item(0).getFirstChild().getNodeValue()) println(\"Motor: \" + el.getElementsByTagName(\"motor\").item(0).getTextContent()) println(\"Combustible: \" + el.getElementsByTagName(\"motor\").item(0).getAttributes().item(0).getNodeValue()) val m = el . getElementsByTagName (\"motor\").item(0) as Element println(\"Combustible: \" + m.getAttribute(\"combustible\")) println() } println(arrel.getTextContent()) } \u00c9s molt important observar que quan tenim un element que ja t\u00e9 contingut, la informaci\u00f3 no \u00e9s accessible, sin\u00f3 que hem d'anar al primer fill, que aquest ja \u00e9s de tips TEXT_NODE , per agafar el seu valor. En l'exemple: Per a marca hem agafat de tota la llista de fills el primer, per traure el seu valor. En matricula en compte d'agafar tota la llista de fills, nom\u00e9s hem agafat el primer, i per tant \u00e9s m\u00e9s r\u00e0pid. I per a motor utilitzem el m\u00e8tode getTextContent , que agafa el congingut de text de l'element i de tots els seus descendents. Com \u00e9s un node de text ja sabem a priori que ens anir\u00e0 b\u00e9, i per tant \u00e9s la forma m\u00e9s r\u00e0pida . L'atribut combustible de l'element motor l'hem tret de 2 maneres: La primera agafant la llista d'atributs, i despr\u00e9s el primer d'aquesta llista. En la segona manera s'ha fet m\u00e9s elegant, anat a buscar la propietat en q\u00fcesti\u00f3. Per aix\u00f2 hem convertit el node en l' element m , per a poder utilitzar getAttribute . Al final fem el getTextContent() sobre l'arrel per a comprovar que trau el seu contingut i el de tots els seus fills, per aix\u00f2 apareix la informaci\u00f3 duplicada Aquest ser\u00e0 el resultat de l'exemple anterior: vehiculo 1 Marca: ford Matr\u00edcula: 1234AAA Motor: duratorc 1.4 Combustible: gasolina Combustible: gasolina vehiculo 2 Marca: ford Matr\u00edcula: 1235AAA Motor: duratorc 2.0 Combustible: diesel Combustible: diesel ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.2.1 Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/421_lectura/#421-lectura","text":"Anem a fer proves per poder comprovar el funcionament. Ens basem en el document cotxes.xml esmentat en la pregunta 4.1 Nota Aneu amb compte, perqu\u00e8 en el document cotxes.xml davant de la primera etiqueta no pot haver ni retorn de carro ni un espai en blanc ni res Coieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_1_XMLMirar.kt package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>){ val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") println(doc.getNodeName()) // torna el nom del document. No \u00e9s l'element arrel. Ens dir\u00e0 #document val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel println(arrel.getNodeName()) // torna el nom de l'element. Ens dir\u00e0 oferta println(arrel.getNodeValue()) // torna el valor de l'element. Com \u00e9s un element que cont\u00e9 altres elements, el valor \u00e9s null } Tal i com est\u00e0 documentat, aquesta ser\u00e0 l'eixida:","title":"4.2.1 Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/421_lectura/#document","text":"oferta null Anem a comprovar ara que el primer fill de oferta no \u00e9s vehiculo sin\u00f3 el retorn de carro. Els element vehiculo s\u00f3n el segon i el quart (\u00edndex 1 i 3). Copieu el seg\u00fcent codi enun fitxer Kotlin anomenat Exemple_3_4_2_XMLMirar2.kt **** package exemples import javax.xml.parsers.DocumentBuilderFactory fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val fills = arrel.getChildNodes() println(fills.item(0).getNodeName()) // el primer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(1).getNodeName()) // el segon fill s\u00ed que \u00e9s vehiculo println(fills.item(2).getNodeName()) // el tercer fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(3).getNodeName()) // el quart fill s\u00ed que \u00e9s vehiculo println(fills.item(4).getNodeName()) // el cinqu\u00e8 fill \u00e9s el retorn de carro; ens dir\u00e0 que \u00e9s de text println(fills.item(5).getNodeName()) // no existeix el sis\u00e8 fill. Donar\u00e0 error } Observeu que en l'\u00faltima sent\u00e8ncia estem provocant un error:","title":"document"},{"location":"AD_T3_Fitxers_de_diferents_formats/421_lectura/#text","text":"vehiculo","title":"text"},{"location":"AD_T3_Fitxers_de_diferents_formats/421_lectura/#text_1","text":"vehiculo","title":"text"},{"location":"AD_T3_Fitxers_de_diferents_formats/421_lectura/#text_2","text":"Exception in thread \"main\" java.lang.NullPointerException at exemples.Exemple_4_2_MirarXML2.main(Exemple_4_2_MirarXML2.kt:15) Per tant, hem d'anar molt en compte amb els retorns de carro . Per a poder esquivar els retorn de carro podr\u00edem mirar el tipus de cada node ( getNodeType() ), menysprear els els de tipus TEXT_NODE i considerar nom\u00e9s els de tipus ELEMENT_NODE . Per\u00f2 normalment l'acc\u00e9s que farem ser\u00e0 un poc m\u00e9s directe i m\u00e9s f\u00e0cil. Agafarem la llista de tots els element que tinguen un determinat nom amb getElementsByTagName( nom ) . * Evidentment en la llista no estaran els retorns de carro * i aix\u00ed no tindrem problemes amb ells. En el seg\u00fcent exemple recorrerem tots els element vehiculo . De cadascun agafarem el contingut dels elements marca i matricula . Tamb\u00e9 agafem el contingut de l'atribut combustible de l'element motor . Guardeu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_4_3_XMLMirarCotxes.kt : package exemples import javax.xml.parsers.DocumentBuilderFactory import org.w3c.dom.Element fun main(args: Array<String>) { val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\"cotxes.xml\") val arrel = doc.getDocumentElement() // apuntar\u00e0 a l'element arrel val llista = arrel.getElementsByTagName(\"vehiculo\") for (i in 0 until llista.getLength()) { val el = llista.item(i) as Element println(el.getNodeName() + \" \" + (i + 1)) println(\"Marca: \" + el.getElementsByTagName(\"marca\").item(0).getChildNodes().item(0).getNodeValue()) println(\"Matr\u00edcula: \" + el.getElementsByTagName(\"matricula\").item(0).getFirstChild().getNodeValue()) println(\"Motor: \" + el.getElementsByTagName(\"motor\").item(0).getTextContent()) println(\"Combustible: \" + el.getElementsByTagName(\"motor\").item(0).getAttributes().item(0).getNodeValue()) val m = el . getElementsByTagName (\"motor\").item(0) as Element println(\"Combustible: \" + m.getAttribute(\"combustible\")) println() } println(arrel.getTextContent()) } \u00c9s molt important observar que quan tenim un element que ja t\u00e9 contingut, la informaci\u00f3 no \u00e9s accessible, sin\u00f3 que hem d'anar al primer fill, que aquest ja \u00e9s de tips TEXT_NODE , per agafar el seu valor. En l'exemple: Per a marca hem agafat de tota la llista de fills el primer, per traure el seu valor. En matricula en compte d'agafar tota la llista de fills, nom\u00e9s hem agafat el primer, i per tant \u00e9s m\u00e9s r\u00e0pid. I per a motor utilitzem el m\u00e8tode getTextContent , que agafa el congingut de text de l'element i de tots els seus descendents. Com \u00e9s un node de text ja sabem a priori que ens anir\u00e0 b\u00e9, i per tant \u00e9s la forma m\u00e9s r\u00e0pida . L'atribut combustible de l'element motor l'hem tret de 2 maneres: La primera agafant la llista d'atributs, i despr\u00e9s el primer d'aquesta llista. En la segona manera s'ha fet m\u00e9s elegant, anat a buscar la propietat en q\u00fcesti\u00f3. Per aix\u00f2 hem convertit el node en l' element m , per a poder utilitzar getAttribute . Al final fem el getTextContent() sobre l'arrel per a comprovar que trau el seu contingut i el de tots els seus fills, per aix\u00f2 apareix la informaci\u00f3 duplicada Aquest ser\u00e0 el resultat de l'exemple anterior: vehiculo 1 Marca: ford Matr\u00edcula: 1234AAA Motor: duratorc 1.4 Combustible: gasolina Combustible: gasolina vehiculo 2 Marca: ford Matr\u00edcula: 1235AAA Motor: duratorc 2.0 Combustible: diesel Combustible: diesel ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"text"},{"location":"AD_T3_Fitxers_de_diferents_formats/422_escriptura/","text":"Acc\u00e9s a Dades 4.2.2 Escriptura Anem ara a crear un nou document XML i a guardar-lo en un fitxer. Utilitzarem com a exemple Empleats . Al final de tot convertirem el fitxer Empleats.obj , generat en la pregunta 3, en el fitxer Empleats.xml . La primera consideraci\u00f3 a fer \u00e9s que partirem d'un document buit. Anirem construint els elements i posant els atributs, i quan tinguem un element creat del tot, l'afegirem a l'estructura, \u00e9s a dir farem que siga el fill d'un que ja est\u00e0 en l'estructura. Podr\u00edem fer-ho tamb\u00e9 al rev\u00e9s, \u00e9s a dir, primer penjar-lo de l'estructura i despr\u00e9s anar omplint-lo. Els principals m\u00e8todes per anar construint l'estructura s\u00f3n: M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element createElement( String nom ) crea un nou element amb el nom indicat (s'haur\u00e0 de penjar en l'estructura) Text createTextNode( String dades ) crea un nou element de text (amb contingut) Node appendChild( Node nou ) afegeix el node nou, que ser\u00e0 l'arrel M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 Node appendChild( Node nou ) afegeix el node nou com a l'\u00faltim fill fins el moment void removeChild( Node vell ) lleva el node vell com a fill M\u00e8todes de ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 void setAttribute( String nom,String valor ) afegeix un nou atribut a l'element, amb el nom i valor indicats void removeAttribute( String nom ) lleva l'atribut de l'element void setTextContent( String dades ) afegeix un fill que ser\u00e0 de text, amb el contingut passat com a par\u00e0metre Anem a fer directament ja l'exemple dels empleats. Totes les dades seran elements, excepte el n\u00famero d'empleat, que farem que siga un atribut d'empleat per a practicar. A l'element arrel li direm empleats. El resultat ha de ser el fitxer Empleats.xml . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_4_4_XMLCrearEmpleats.kt : import java.io.ObjectInputStream import java.io.FileInputStream import javax.xml.parsers.DocumentBuilderFactory import java.io.EOFException import javax.xml.transform.TransformerFactory import javax.xml.transform.dom.DOMSource import javax.xml.transform.stream.StreamResult import javax.xml.transform.OutputKeys fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream (\"Empleats.obj\")) val doc = DocumentBuilderFactory.newInstance ().newDocumentBuilder().newDocument() val arrel = doc.createElement (\"empleats\") doc.appendChild(arrel) try { while (true) { val e = f.readObject () as Empleat val emp = doc.createElement (\"empleat\") emp.setAttribute(\"numero\", Integer.toString(e.num)) val nom = doc.createElement (\"nom\") nom.appendChild(doc.createTextNode(e.nom)) // forma llarga: afegim un fill que \u00e9s un node de text emp.appendChild(nom) val dep = doc.createElement(\"departament\") dep.setTextContent(e.departament.toString()) // forma curta: amb setTextContent() li posem contingut emp.appendChild(dep) val edat = doc.createElement(\"edat\") edat.setTextContent(e.edat.toString()) emp.appendChild(edat) val sou = doc.createElement(\"sou\"); sou.setTextContent(e.sou.toString()) emp.appendChild(sou) arrel.appendChild(emp) } } catch (eof: EOFException) { f.close(); } val trans = TransformerFactory.newInstance().newTransformer() trans.transform(DOMSource(doc), StreamResult(\"Empleats.xml\")) } En el fitxer XML generat, observareu que no hi ha retorns de carro, tot est\u00e0 en una mateixa l\u00ednia. Si voleu veure'l b\u00e9, el podeu obrir per exemple amb un navegador web, que interpreta b\u00e9 el format XML. Per\u00f2 tamb\u00e9 podem crear el fitxer donant-li un aspecte agradable incorporant aquestes dues l\u00ednies immediatament abans de crear el fitxer, \u00e9s a dir, immediatament abans de la l\u00ednia 49: trans.setOutputProperty(OutputKeys.INDENT, \"yes\") trans.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\") I el fitxer quedar\u00e0 aix\u00ed: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <empleats> <empleat numero=\"1\"> <nom>Andreu</nom> <departament>10</departament> <edat>32</edat> <sou>1000.0</sou> </empleat> <empleat numero=\"2\"> <nom>Bernat</nom> <departament>20</departament> <edat>28</edat> <sou>1200.0</sou> </empleat> <empleat numero=\"3\"> <nom>Cl\u00e0udia</nom> <departament>10</departament> <edat>26</edat> <sou>1100.0</sou> </empleat> <empleat numero=\"4\"> <nom>Dami\u00e0</nom> <departament>10</departament> <edat>40</edat> <sou>1500.0</sou> </empleat> </empleats> Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.2.2 Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/422_escriptura/#422-escriptura","text":"Anem ara a crear un nou document XML i a guardar-lo en un fitxer. Utilitzarem com a exemple Empleats . Al final de tot convertirem el fitxer Empleats.obj , generat en la pregunta 3, en el fitxer Empleats.xml . La primera consideraci\u00f3 a fer \u00e9s que partirem d'un document buit. Anirem construint els elements i posant els atributs, i quan tinguem un element creat del tot, l'afegirem a l'estructura, \u00e9s a dir farem que siga el fill d'un que ja est\u00e0 en l'estructura. Podr\u00edem fer-ho tamb\u00e9 al rev\u00e9s, \u00e9s a dir, primer penjar-lo de l'estructura i despr\u00e9s anar omplint-lo. Els principals m\u00e8todes per anar construint l'estructura s\u00f3n: M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element createElement( String nom ) crea un nou element amb el nom indicat (s'haur\u00e0 de penjar en l'estructura) Text createTextNode( String dades ) crea un nou element de text (amb contingut) Node appendChild( Node nou ) afegeix el node nou, que ser\u00e0 l'arrel M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 Node appendChild( Node nou ) afegeix el node nou com a l'\u00faltim fill fins el moment void removeChild( Node vell ) lleva el node vell com a fill M\u00e8todes de ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 void setAttribute( String nom,String valor ) afegeix un nou atribut a l'element, amb el nom i valor indicats void removeAttribute( String nom ) lleva l'atribut de l'element void setTextContent( String dades ) afegeix un fill que ser\u00e0 de text, amb el contingut passat com a par\u00e0metre Anem a fer directament ja l'exemple dels empleats. Totes les dades seran elements, excepte el n\u00famero d'empleat, que farem que siga un atribut d'empleat per a practicar. A l'element arrel li direm empleats. El resultat ha de ser el fitxer Empleats.xml . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_4_4_XMLCrearEmpleats.kt : import java.io.ObjectInputStream import java.io.FileInputStream import javax.xml.parsers.DocumentBuilderFactory import java.io.EOFException import javax.xml.transform.TransformerFactory import javax.xml.transform.dom.DOMSource import javax.xml.transform.stream.StreamResult import javax.xml.transform.OutputKeys fun main(args: Array<String>) { val f = ObjectInputStream(FileInputStream (\"Empleats.obj\")) val doc = DocumentBuilderFactory.newInstance ().newDocumentBuilder().newDocument() val arrel = doc.createElement (\"empleats\") doc.appendChild(arrel) try { while (true) { val e = f.readObject () as Empleat val emp = doc.createElement (\"empleat\") emp.setAttribute(\"numero\", Integer.toString(e.num)) val nom = doc.createElement (\"nom\") nom.appendChild(doc.createTextNode(e.nom)) // forma llarga: afegim un fill que \u00e9s un node de text emp.appendChild(nom) val dep = doc.createElement(\"departament\") dep.setTextContent(e.departament.toString()) // forma curta: amb setTextContent() li posem contingut emp.appendChild(dep) val edat = doc.createElement(\"edat\") edat.setTextContent(e.edat.toString()) emp.appendChild(edat) val sou = doc.createElement(\"sou\"); sou.setTextContent(e.sou.toString()) emp.appendChild(sou) arrel.appendChild(emp) } } catch (eof: EOFException) { f.close(); } val trans = TransformerFactory.newInstance().newTransformer() trans.transform(DOMSource(doc), StreamResult(\"Empleats.xml\")) } En el fitxer XML generat, observareu que no hi ha retorns de carro, tot est\u00e0 en una mateixa l\u00ednia. Si voleu veure'l b\u00e9, el podeu obrir per exemple amb un navegador web, que interpreta b\u00e9 el format XML. Per\u00f2 tamb\u00e9 podem crear el fitxer donant-li un aspecte agradable incorporant aquestes dues l\u00ednies immediatament abans de crear el fitxer, \u00e9s a dir, immediatament abans de la l\u00ednia 49: trans.setOutputProperty(OutputKeys.INDENT, \"yes\") trans.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\") I el fitxer quedar\u00e0 aix\u00ed: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <empleats> <empleat numero=\"1\"> <nom>Andreu</nom> <departament>10</departament> <edat>32</edat> <sou>1000.0</sou> </empleat> <empleat numero=\"2\"> <nom>Bernat</nom> <departament>20</departament> <edat>28</edat> <sou>1200.0</sou> </empleat> <empleat numero=\"3\"> <nom>Cl\u00e0udia</nom> <departament>10</departament> <edat>26</edat> <sou>1100.0</sou> </empleat> <empleat numero=\"4\"> <nom>Dami\u00e0</nom> <departament>10</departament> <edat>40</edat> <sou>1500.0</sou> </empleat> </empleats> Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.2.2 Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/42__lestructura_dom/","text":"Acc\u00e9s a Dades 4.2 - L'estructura DOM L\u2019estructura DOM pren la forma d\u2019un arbre, on cada part del XML es trobar\u00e0 representada en forma de node . En funci\u00f3 de la posici\u00f3 en el document XML, parlarem de diferents tipus de nodes: El node principal que representa tot el XML sencer s\u2019anomena Document. Les diverses etiquetes, inclosa l\u2019etiqueta arrel, es coneixen com a nodes Element . El contingut d\u2019una etiqueta de tipus text, ser\u00e0 un node de tipus TextElement Els atributs seran nodes de tipus Attribute . En l'exemple de la p\u00e0gina anterior, el fitxer cotxes.xml , que t\u00e9 aquesta estructura: ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg Veient-lo com una estructura jer\u00e0rquica ens quedaria aix\u00ed: On: El node Document \u00e9s el rombe Els nodes Element s\u00f3n els cercles Els nodes TextElement s\u00f3n els rect\u00e0ngles de fons taronja. Els nodes Attribute s\u00f3n els rect\u00e0ngles arrodonits de color groc Cada node espec\u00edfic disposa de m\u00e8todes per accedir a les seues dades concretes (nom, valor, nodes fills, node pare, etc.). \u00c9s a dir, que el node serveix per a situar-se en una determinada posici\u00f3 (element, atribut, element de text, ...). Tindr\u00e0 uns m\u00e8todes, sobretot per a navegar, encara que tamb\u00e9 alguns per a traure el contingut. Element \u00e9s un classe derivada de Node (per tant hereta tots els seus m\u00e8todes), i proporciona algunes coses m\u00e9s, sobretot per a accedir c\u00f2modament a les seues parts. Mirem els m\u00e8todes m\u00e9s importants, tant de Node com de Element i Document M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 String getNodeName() torna el nom d'aquest node short getNodeType() torna el tipus d'aquest node (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, ... String getNodeValue() torna el valor del node, si en t\u00e9 NodeList getChildNodes() torna una llista amb els nodes fills Node getFirstChild() torna el primer fill Node getLastChild() torna l'\u00faltim fill NamedNodeMap getAttributes() torna una llista amb els atributs del node (null si no en t\u00e9 cap) Node getParentNode() torna el pare String getTextContent() torna el text contingut en l'element i el de tots els seus descendents, si en t\u00e9 boolean hasChildNodes() torna cert si el node t\u00e9 algun fill boolean hasAttributes() torna cert si el node t\u00e9 algun atribut M\u00e8todes d' ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 String getAttribute( String nom ) torna el valor de l'atribut que t\u00e9 aquest nom NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom boolean hasAttribute( String nom ) torna cert si l'element t\u00e9 aquest atribut M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element getDocumentElement() torna l'element arrel del document NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom Nota Kotlin ens \"suggerir\u00e0\" canviar molts dels m\u00e8todes anteriors per propietats. Per exemple per al m\u00e8tode getNodeName() ens suggerir\u00e0 de canviar-lo per la propietat nodeName . Podeu substituir per la propietat o deixar el m\u00e8tode, el que vulgueu. Sempre que tinguem una llista de nodes , podrem accedir a cadascun dels membres de la llista amb el m\u00e8tode item especificant el n\u00famero d'ordre. Aix\u00ed, si volem accedir al primer posarem item(0) Posterioment posarem els m\u00e8todes que serveixen per anar posant contingut a un document: crear fills, crear atributs, posar contingut, ... El DOM resultant obtingut des d\u2019un XML acaba sent un c\u00f2pia exacta del fitxer, per\u00f2 disposat de diferent manera. Tant al XML com al DOM hi haur\u00e0 informaci\u00f3 no visible, com ara els retorns de carro , que cal tenir en compte per tal de saber processar correctament el contingut i evitar sorpreses poc comprensibles. Per a il\u00b7lustrar el problema que poden suposar els retorn de carro, imaginem que disposem d\u2019un document XML amb el seg\u00fcent contingut: Veurem m\u00e9s clar si representem els retorn de carro en el mateix document: \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 A la seg\u00fcent figura es mostra la representaci\u00f3 que tindria l\u2019objecte DOM, un vegada estiga ja copiat en mem\u00f2ria. Observeu com l\u2019element ** table tindr\u00e0 tres fills. En un es guardar\u00e0 el retorn de carro que situa l\u2019etiqueta < tr> a la seg\u00fcent l\u00ednia, en el segon trobarem l\u2019etiqueta < tr> , i en el tercer el retorn de carro que fa que < /table> estiga en la l\u00ednia de baix. El mateix passa amb els fills de < tr> , abans i despr\u00e9s de cada node < td> trobarem un retorn de carro**. En canvi, si hagu\u00e9rem partit d'un XML equivalent per\u00f2 sense retorns de carro, el resultat hauria estat diferent: L\u2019abs\u00e8ncia de retorns de carro en el fitxer implica tamb\u00e9 l\u2019abs\u00e8ncia de nodes contenint els retorns de carro en l\u2019estructura DOM. Un altre aspecte a tenir en compte \u00e9s que el contingut de les etiquetes es plasma en el DOM com un node fill de l\u2019etiqueta contenidora. \u00c9s a dir, per obtenir el text d\u2019una etiqueta cal obtenir el primer fill d\u2019aquesta. text de l'etiqueta bbb Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"42  lestructura dom"},{"location":"AD_T3_Fitxers_de_diferents_formats/42__lestructura_dom/#42-lestructura-dom","text":"L\u2019estructura DOM pren la forma d\u2019un arbre, on cada part del XML es trobar\u00e0 representada en forma de node . En funci\u00f3 de la posici\u00f3 en el document XML, parlarem de diferents tipus de nodes: El node principal que representa tot el XML sencer s\u2019anomena Document. Les diverses etiquetes, inclosa l\u2019etiqueta arrel, es coneixen com a nodes Element . El contingut d\u2019una etiqueta de tipus text, ser\u00e0 un node de tipus TextElement Els atributs seran nodes de tipus Attribute . En l'exemple de la p\u00e0gina anterior, el fitxer cotxes.xml , que t\u00e9 aquesta estructura: ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg Veient-lo com una estructura jer\u00e0rquica ens quedaria aix\u00ed: On: El node Document \u00e9s el rombe Els nodes Element s\u00f3n els cercles Els nodes TextElement s\u00f3n els rect\u00e0ngles de fons taronja. Els nodes Attribute s\u00f3n els rect\u00e0ngles arrodonits de color groc Cada node espec\u00edfic disposa de m\u00e8todes per accedir a les seues dades concretes (nom, valor, nodes fills, node pare, etc.). \u00c9s a dir, que el node serveix per a situar-se en una determinada posici\u00f3 (element, atribut, element de text, ...). Tindr\u00e0 uns m\u00e8todes, sobretot per a navegar, encara que tamb\u00e9 alguns per a traure el contingut. Element \u00e9s un classe derivada de Node (per tant hereta tots els seus m\u00e8todes), i proporciona algunes coses m\u00e9s, sobretot per a accedir c\u00f2modament a les seues parts. Mirem els m\u00e8todes m\u00e9s importants, tant de Node com de Element i Document M\u00e8todes de NODE Valor tornat M\u00e8tode Descripci\u00f3 String getNodeName() torna el nom d'aquest node short getNodeType() torna el tipus d'aquest node (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, ... String getNodeValue() torna el valor del node, si en t\u00e9 NodeList getChildNodes() torna una llista amb els nodes fills Node getFirstChild() torna el primer fill Node getLastChild() torna l'\u00faltim fill NamedNodeMap getAttributes() torna una llista amb els atributs del node (null si no en t\u00e9 cap) Node getParentNode() torna el pare String getTextContent() torna el text contingut en l'element i el de tots els seus descendents, si en t\u00e9 boolean hasChildNodes() torna cert si el node t\u00e9 algun fill boolean hasAttributes() torna cert si el node t\u00e9 algun atribut M\u00e8todes d' ELEMENT Valor tornat M\u00e8tode Descripci\u00f3 String getAttribute( String nom ) torna el valor de l'atribut que t\u00e9 aquest nom NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom boolean hasAttribute( String nom ) torna cert si l'element t\u00e9 aquest atribut M\u00e8todes de DOCUMENT Valor tornat M\u00e8tode Descripci\u00f3 Element getDocumentElement() torna l'element arrel del document NodeList getElementsByTagName( String nom ) torna una llista de nodes amb tots els descendents que tenen aquest nom Nota Kotlin ens \"suggerir\u00e0\" canviar molts dels m\u00e8todes anteriors per propietats. Per exemple per al m\u00e8tode getNodeName() ens suggerir\u00e0 de canviar-lo per la propietat nodeName . Podeu substituir per la propietat o deixar el m\u00e8tode, el que vulgueu. Sempre que tinguem una llista de nodes , podrem accedir a cadascun dels membres de la llista amb el m\u00e8tode item especificant el n\u00famero d'ordre. Aix\u00ed, si volem accedir al primer posarem item(0) Posterioment posarem els m\u00e8todes que serveixen per anar posant contingut a un document: crear fills, crear atributs, posar contingut, ... El DOM resultant obtingut des d\u2019un XML acaba sent un c\u00f2pia exacta del fitxer, per\u00f2 disposat de diferent manera. Tant al XML com al DOM hi haur\u00e0 informaci\u00f3 no visible, com ara els retorns de carro , que cal tenir en compte per tal de saber processar correctament el contingut i evitar sorpreses poc comprensibles. Per a il\u00b7lustrar el problema que poden suposar els retorn de carro, imaginem que disposem d\u2019un document XML amb el seg\u00fcent contingut: Veurem m\u00e9s clar si representem els retorn de carro en el mateix document: \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 A la seg\u00fcent figura es mostra la representaci\u00f3 que tindria l\u2019objecte DOM, un vegada estiga ja copiat en mem\u00f2ria. Observeu com l\u2019element ** table tindr\u00e0 tres fills. En un es guardar\u00e0 el retorn de carro que situa l\u2019etiqueta < tr> a la seg\u00fcent l\u00ednia, en el segon trobarem l\u2019etiqueta < tr> , i en el tercer el retorn de carro que fa que < /table> estiga en la l\u00ednia de baix. El mateix passa amb els fills de < tr> , abans i despr\u00e9s de cada node < td> trobarem un retorn de carro**. En canvi, si hagu\u00e9rem partit d'un XML equivalent per\u00f2 sense retorns de carro, el resultat hauria estat diferent: L\u2019abs\u00e8ncia de retorns de carro en el fitxer implica tamb\u00e9 l\u2019abs\u00e8ncia de nodes contenint els retorns de carro en l\u2019estructura DOM. Un altre aspecte a tenir en compte \u00e9s que el contingut de les etiquetes es plasma en el DOM com un node fill de l\u2019etiqueta contenidora. \u00c9s a dir, per obtenir el text d\u2019una etiqueta cal obtenir el primer fill d\u2019aquesta. text de l'etiqueta bbb Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.2 - L'estructura DOM"},{"location":"AD_T3_Fitxers_de_diferents_formats/43__binding/","text":"Acc\u00e9s a Dades 4.3 - Binding VOLUNTARI El Binding \u00e9s una t\u00e8cnica que consisteix en generar (i vincular) autom\u00e0ticament classes de Java amb formats espec\u00edfics d\u2019emmagatzematge, que en el cas que ens interessa seran documents XML. D'aquesta manera, cada etiqueta o atribut de XML es correspondr\u00e0 amb una propietat d'una determinada classe. Aix\u00f2 s'anomena mapar , perqu\u00e8 \u00e9s fer una esp\u00e8cie de mapa per a indicar que una etiqueta (o atribut) es correspon a una propietat de la classe. Per a poder fer la aquesta correspond\u00e8ncia o mapatge de forma correcta entre les classes de Java i el document XML, far\u00e0 falta una miqueta d'ajuda o aclaracions, perqu\u00e8 com ja hem vist la mateixa informaci\u00f3 es pot guardar de m\u00e9s d'una manera en XML (utilitzant o no atributs, ...). En Java existeixen diverses biblioteques per gestionar el binding , com per exemple JAXB , JiBX , XMLBinding , etc. Des de la versi\u00f3 6.0 s\u2019ha incorporat en el JDK est\u00e0ndard JAXB ( Java Architecture for XML Binding ), una potent biblioteca. JAXB utilitza Anotacions per aconseguir la informaci\u00f3 extra necess\u00e0ria per mapar el binding . Les Anotacions s\u00f3n unes classes de Java molt especials. Serveixen per associar informaci\u00f3 i funcionalitat als objectes sense interferir en l\u2019estructura del model de dades. Abans d'apar\u00e9ixer les Anotacions era necessari fer servir l\u2019her\u00e8ncia per poder afegir funcionalitat a una classe sense haver de codificar-la, per\u00f2 ho complicava molt. Si, per contra, fem servir Anotacions , els objectes disposaran d\u2019informaci\u00f3 o de funcionalitat extra sense que el model de dades quede modificat, ja que les Anotacions no s\u00f3n visibles des dels objectes. Les Anotacions poden associar-se a un paquet, a una classe, a un atribut o fins i tot a un par\u00e0metre. Aquestes classes especials es declaren en el codi de l\u2019aplicaci\u00f3 posant el s\u00edmbol @ davant del nom de l\u2019 Anotaci\u00f3 . Quan el compilador de Java detecta una Anotaci\u00f3 crea una inst\u00e0ncia i la injecta dins l\u2019element afectat (paquet, classe, m\u00e8tode, atribut, etc.). Aix\u00f2 fa que aquestes no apareguen com a atributs o m\u00e8todes propis de l\u2019objecte, i per aix\u00f2 diem que no interacciona amb el model de dades, per\u00f2 les aplicacions que ho necessiten poden obtenir la inst\u00e0ncia injectada i fer-la servir. Nosaltres en aquest curs, \u00fanicament aspirarem a veure com realment a partir d'un esquema XML que valida una s\u00e8rie de documents XML, podem generar c\u00f2modament les classes en Java, que permetrien guardar objectes d'aquestes classes. Una vegada constru\u00efdes les classes es podria utilitzar JAXB per a transferir informaci\u00f3 dels fitxers XML (v\u00e0lids per a l'esquema) cap als objectes o a l'inrev\u00e8s. La generaci\u00f3 de les classes \u00e9s extremadament senzilla a partir d'una determinada versi\u00f3 d'Eclipse. Com hem comentat la llibreria JAXB est\u00e0 present des de la versi\u00f3 6.0 del JDK SE (Standard Edition). Per\u00f2 per a la generaci\u00f3 c\u00f2moda ens fan falta eines (tools) proporcionades en la JDK EE 7.0 (Enterprise Edition). Si tenim aquesta plataforma podrem utilitzar la versi\u00f3 2.2 de JAXB. Nota Lamentablement, a partir de la versi\u00f3 de Java JDK EE 8.0 comen\u00e7a a estar en des\u00fas el JAXB ( deprecated ), i a la versi\u00f3 11 ja no est\u00e0 implementat. Per tant, per a poder provar el que va a continuaci\u00f3 \u00e9s preferible que utilitzeu una versi\u00f3 antiga de Java (Java 7 o Java 8). Si no la teniu instal\u00b7lada, no valdr\u00e0 la pena que feu aquest exemple. Per aix\u00f2 aquesta pregunta \u00e9s volunt\u00e0ria . Evidentment, es pot aconseguir que funcione en Java 11, a pesar que no est\u00e0 implementat JAXB, per\u00f2 \u00e9s a costa d'assenyalar que agafe configuracions anteriors, o important tots els jar necessaris, baixant-los pr\u00e8viament. No valdr\u00e0 la pena, perqu\u00e8 no l'utilitzarem Ens recolzarem en un exemple utilitzat l'any passat. El seg\u00fcent esquema (.xsd) valida documents com el de l'oferta de vehicles, vist en apartats anteriors. Podeu guardar-lo amb el nom cotxes.xsd <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:simpleType name=\"Combust\"> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"gasolina\"/> <xs:enumeration value=\"diesel\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"Matr\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"[0-9]{4}[A-Z]{3}\"/> </xs:restriction> </xs:simpleType> <xs:element name=\"oferta\"> <xs:complexType> <xs:sequence> <xs:element name=\"vehiculo\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:sequence> <xs:element name=\"marca\" type=\"xs:string\"/> <xs:element name=\"modelo\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"color\" type=\"xs:string\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"motor\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"combustible\" type=\"Combust\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"matricula\" type=\"Matr\"/> <xs:element name=\"kilometros\" type=\"xs:integer\"/> <xs:element name=\"precio_inicial\" type=\"xs:integer\"/> <xs:element name=\"precio_oferta\" type=\"xs:integer\"/> <xs:element name=\"extra\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"valor\" type=\"xs:integer\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"foto\" maxOccurs=\"unbounded\" type=\"xs:string\"/> </xs:sequence> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Per exemple, el seg\u00fcent document XML cotxes.xml (el vist en els apartats anteriors) \u00e9s v\u00e0lid segons l'anterior esquema. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> Per\u00f2 per a generar les classes el que ens fa falta \u00e9s el de l'esquema, cotxes.xsd . En el seg\u00fcent v\u00eddeo es veu com generar les classes a partir de l'esquema. No cal que ho feu si no voleu, perqu\u00e8 es mostra a nivell \u00fanicament il\u00b7lustratiu de com es generen les classes, per\u00f2 no ho utilitzarem despr\u00e9s I aquest \u00e9s el programa per provar que es pot accedir que es comenta en el v\u00eddeo: package classesJAXB import java.io.File import javax.xml.bind.JAXBContext import javax.xml.bind.JAXBException fun main() { try { val file = File(\"cotxes.xml\") val jaxbContext = JAXBContext.newInstance(Oferta::class.java) val jaxbUnmarshaller = jaxbContext.createUnmarshaller() val oferta = jaxbUnmarshaller.unmarshal(file) as Oferta for (v in oferta.getVehiculo()) println(v.getMatricula() + \" (\" + v.getMarca() + \")\") } catch (e: JAXBException) { e.printStackTrace() } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4.3 - Binding"},{"location":"AD_T3_Fitxers_de_diferents_formats/43__binding/#43-binding","text":"","title":"4.3 - Binding"},{"location":"AD_T3_Fitxers_de_diferents_formats/43__binding/#voluntari","text":"El Binding \u00e9s una t\u00e8cnica que consisteix en generar (i vincular) autom\u00e0ticament classes de Java amb formats espec\u00edfics d\u2019emmagatzematge, que en el cas que ens interessa seran documents XML. D'aquesta manera, cada etiqueta o atribut de XML es correspondr\u00e0 amb una propietat d'una determinada classe. Aix\u00f2 s'anomena mapar , perqu\u00e8 \u00e9s fer una esp\u00e8cie de mapa per a indicar que una etiqueta (o atribut) es correspon a una propietat de la classe. Per a poder fer la aquesta correspond\u00e8ncia o mapatge de forma correcta entre les classes de Java i el document XML, far\u00e0 falta una miqueta d'ajuda o aclaracions, perqu\u00e8 com ja hem vist la mateixa informaci\u00f3 es pot guardar de m\u00e9s d'una manera en XML (utilitzant o no atributs, ...). En Java existeixen diverses biblioteques per gestionar el binding , com per exemple JAXB , JiBX , XMLBinding , etc. Des de la versi\u00f3 6.0 s\u2019ha incorporat en el JDK est\u00e0ndard JAXB ( Java Architecture for XML Binding ), una potent biblioteca. JAXB utilitza Anotacions per aconseguir la informaci\u00f3 extra necess\u00e0ria per mapar el binding . Les Anotacions s\u00f3n unes classes de Java molt especials. Serveixen per associar informaci\u00f3 i funcionalitat als objectes sense interferir en l\u2019estructura del model de dades. Abans d'apar\u00e9ixer les Anotacions era necessari fer servir l\u2019her\u00e8ncia per poder afegir funcionalitat a una classe sense haver de codificar-la, per\u00f2 ho complicava molt. Si, per contra, fem servir Anotacions , els objectes disposaran d\u2019informaci\u00f3 o de funcionalitat extra sense que el model de dades quede modificat, ja que les Anotacions no s\u00f3n visibles des dels objectes. Les Anotacions poden associar-se a un paquet, a una classe, a un atribut o fins i tot a un par\u00e0metre. Aquestes classes especials es declaren en el codi de l\u2019aplicaci\u00f3 posant el s\u00edmbol @ davant del nom de l\u2019 Anotaci\u00f3 . Quan el compilador de Java detecta una Anotaci\u00f3 crea una inst\u00e0ncia i la injecta dins l\u2019element afectat (paquet, classe, m\u00e8tode, atribut, etc.). Aix\u00f2 fa que aquestes no apareguen com a atributs o m\u00e8todes propis de l\u2019objecte, i per aix\u00f2 diem que no interacciona amb el model de dades, per\u00f2 les aplicacions que ho necessiten poden obtenir la inst\u00e0ncia injectada i fer-la servir. Nosaltres en aquest curs, \u00fanicament aspirarem a veure com realment a partir d'un esquema XML que valida una s\u00e8rie de documents XML, podem generar c\u00f2modament les classes en Java, que permetrien guardar objectes d'aquestes classes. Una vegada constru\u00efdes les classes es podria utilitzar JAXB per a transferir informaci\u00f3 dels fitxers XML (v\u00e0lids per a l'esquema) cap als objectes o a l'inrev\u00e8s. La generaci\u00f3 de les classes \u00e9s extremadament senzilla a partir d'una determinada versi\u00f3 d'Eclipse. Com hem comentat la llibreria JAXB est\u00e0 present des de la versi\u00f3 6.0 del JDK SE (Standard Edition). Per\u00f2 per a la generaci\u00f3 c\u00f2moda ens fan falta eines (tools) proporcionades en la JDK EE 7.0 (Enterprise Edition). Si tenim aquesta plataforma podrem utilitzar la versi\u00f3 2.2 de JAXB. Nota Lamentablement, a partir de la versi\u00f3 de Java JDK EE 8.0 comen\u00e7a a estar en des\u00fas el JAXB ( deprecated ), i a la versi\u00f3 11 ja no est\u00e0 implementat. Per tant, per a poder provar el que va a continuaci\u00f3 \u00e9s preferible que utilitzeu una versi\u00f3 antiga de Java (Java 7 o Java 8). Si no la teniu instal\u00b7lada, no valdr\u00e0 la pena que feu aquest exemple. Per aix\u00f2 aquesta pregunta \u00e9s volunt\u00e0ria . Evidentment, es pot aconseguir que funcione en Java 11, a pesar que no est\u00e0 implementat JAXB, per\u00f2 \u00e9s a costa d'assenyalar que agafe configuracions anteriors, o important tots els jar necessaris, baixant-los pr\u00e8viament. No valdr\u00e0 la pena, perqu\u00e8 no l'utilitzarem Ens recolzarem en un exemple utilitzat l'any passat. El seg\u00fcent esquema (.xsd) valida documents com el de l'oferta de vehicles, vist en apartats anteriors. Podeu guardar-lo amb el nom cotxes.xsd <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:simpleType name=\"Combust\"> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"gasolina\"/> <xs:enumeration value=\"diesel\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"Matr\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"[0-9]{4}[A-Z]{3}\"/> </xs:restriction> </xs:simpleType> <xs:element name=\"oferta\"> <xs:complexType> <xs:sequence> <xs:element name=\"vehiculo\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:sequence> <xs:element name=\"marca\" type=\"xs:string\"/> <xs:element name=\"modelo\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"color\" type=\"xs:string\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"motor\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"combustible\" type=\"Combust\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"matricula\" type=\"Matr\"/> <xs:element name=\"kilometros\" type=\"xs:integer\"/> <xs:element name=\"precio_inicial\" type=\"xs:integer\"/> <xs:element name=\"precio_oferta\" type=\"xs:integer\"/> <xs:element name=\"extra\" maxOccurs=\"unbounded\" > <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"valor\" type=\"xs:integer\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> <xs:element name=\"foto\" maxOccurs=\"unbounded\" type=\"xs:string\"/> </xs:sequence> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Per exemple, el seg\u00fcent document XML cotxes.xml (el vist en els apartats anteriors) \u00e9s v\u00e0lid segons l'anterior esquema. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <oferta> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"gasolina\">duratorc 1.4</motor> <matricula>1234AAA</matricula> <kilometros>12500</kilometros> <precio_inicial>12000</precio_inicial> <precio_oferta>10000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"300\">llantas</extra> <foto>11325.jpg</foto> <foto>11326.jpg</foto> </vehiculo> <vehiculo> <marca>ford</marca> <modelo color=\"gris\">focus</modelo> <motor combustible=\"diesel\">duratorc 2.0</motor> <matricula>1235AAA</matricula> <kilometros>125000</kilometros> <precio_inicial>10000</precio_inicial> <precio_oferta>9000</precio_oferta> <extra valor=\"250\">pintura metalizada</extra> <extra valor=\"200\">spoiler trasero</extra> <extra valor=\"500\">climatizador</extra> <foto>11327.jpg</foto> <foto>11328.jpg</foto> </vehiculo> </oferta> Per\u00f2 per a generar les classes el que ens fa falta \u00e9s el de l'esquema, cotxes.xsd . En el seg\u00fcent v\u00eddeo es veu com generar les classes a partir de l'esquema. No cal que ho feu si no voleu, perqu\u00e8 es mostra a nivell \u00fanicament il\u00b7lustratiu de com es generen les classes, per\u00f2 no ho utilitzarem despr\u00e9s I aquest \u00e9s el programa per provar que es pot accedir que es comenta en el v\u00eddeo: package classesJAXB import java.io.File import javax.xml.bind.JAXBContext import javax.xml.bind.JAXBException fun main() { try { val file = File(\"cotxes.xml\") val jaxbContext = JAXBContext.newInstance(Oferta::class.java) val jaxbUnmarshaller = jaxbContext.createUnmarshaller() val oferta = jaxbUnmarshaller.unmarshal(file) as Oferta for (v in oferta.getVehiculo()) println(v.getMatricula() + \" (\" + v.getMarca() + \")\") } catch (e: JAXBException) { e.printStackTrace() } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"VOLUNTARI"},{"location":"AD_T3_Fitxers_de_diferents_formats/4_documents_xml/","text":"Acc\u00e9s a Dades # 4.- Documents XML Hem vist que la manera m\u00e9s c\u00f2moda de guardar objectes \u00e9s amb la seriaci\u00f3, per mig del ObjectInputStream i ObjectOutputStream , per\u00f2 que fora de Java o de Kotlin no \u00e9s possible l'acc\u00e9s a aquestes dades. I com hav\u00edem comentat en l'\u00faltima nota de la pregunta anterior, tamb\u00e9 dins de Kotlin podem tenir problemes, perqu\u00e8 el nom de la classe amb el nom del paquet es guarda en el fitxer com a metades, i en un altre programa haurem de tenir la classe creada en un paquet amb el mateix nom, sin\u00f3 no es podran recuperar les dades. I fins i tot dient-se exactament igual, poden haver problemes si el serialVersionUID de la classe no \u00e9s el mateix. Tamb\u00e9 hem vist que per a guardar dades individuals de diferents tipus ens van molt b\u00e9 les classes DataInputStream i DataOutputStream , per\u00f2 haurem de saber molt b\u00e9 l'ordre i tipus de dades que estan guardades, sin\u00f3, no les podrem recuperar. I no entrem ja en la possibilitat que diferents Sistemes Operatius representen la informaci\u00f3 de forma diferent (per exemple, hi ha Sistemes Operatius que representen els n\u00fameros amb BCD i altres que utilitzen complement a 2). Per tant, quan vulguem guardar dades que puguen ser llegides per aplicacions fetes en diferents llenguatges i/o executades en diferents plataformes, ens far\u00e0 falta un format est\u00e0ndar que tots el puguen entendre i recon\u00e9ixer, i millor si \u00e9s autoexplicatiu com \u00e9s el cas dels llenguatges de marques . El llenguatge de marques m\u00e9s conegut i m\u00e9s utilitzat \u00e9s el XML ( eXtensible Markup Language ) Els documents XML aconsegueixen estructurar la informaci\u00f3 intercalant unes marques anomenades etiquetes, cada etiqueta amb un principi i un final, i que poden anar unes dins d'unes altres, i tamb\u00e9 contenir informaci\u00f3 de text. D\u2019aquesta manera, es podr\u00e0 subdividir la informaci\u00f3 estructurant-la de forma que puga ser f\u00e0cilment interpretada. Tota la informaci\u00f3 ser\u00e0 de text, i per tant no hi haur\u00e0 el problema mencionat abans de representar les dades de diferent manera. Qualsevol dada, ja siga num\u00e8rica, booleana o com siga, es posar\u00e0 en mode text, i per tant sempre es podr\u00e0 llegir i interpretar correctament tota la informaci\u00f3 continguda en un fitxer XML. \u00c9s cert que els car\u00e0cters es poden escriure utilitzant diferents sistemes de codificaci\u00f3, per\u00f2 XML ofereix diverses t\u00e8cniques per evitar que aix\u00f2 siga un problema, com per exemple, incloent a la cap\u00e7alera del fitxer quina codificaci\u00f3 s\u2019ha fet servir en el moment de guardar-lo. Amb les etiquetes, XML aconsegueix estructurar qualsevol tipus d\u2019informaci\u00f3 jer\u00e0rquica. Es pot establir certa similitud entre la forma com la informaci\u00f3 es guarda en els objectes d\u2019una aplicaci\u00f3 i la forma com es guardaria en un document XML. La informaci\u00f3, en les aplicacions orientades a objectes, s\u2019estructura, agrupa i jerarquitza en classes, i en els documents XML s\u2019estructura, organitza i jerarquitza en etiquetes contingudes unes dins les altres i atributs de les etiquetes. Imaginem que volem representar les dades dels empleats com els de l\u2019aparat anterior utilitzant un format XML. No existeix una \u00fanica soluci\u00f3, per\u00f2 \u00e9s obligatori que totes respecten la jerarquia del model. Un possible format podria ser el seg\u00fcent: 1 Andreu 10 32 1000.0 2 Bernat 20 28 1200.0 3 Cl\u00e0udia 10 26 1100.0 4 Dami\u00e0 10 40 1500.0 Per\u00f2 aquesta tamb\u00e9 podria ser una manera de representar-lo: I podem imaginar moltes altres solucions, combinant considerant com atributs o subetiquetes les diferents caracter\u00edstiques dels empleats que volem guardar. Aquest seria el problema principal del XML, les m\u00faltiples solucions. Per\u00f2 tamb\u00e9 \u00e9s veritat que totes elles s\u00f3n f\u00e0cils d'entendre. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 documents xml"},{"location":"AD_T3_Fitxers_de_diferents_formats/51__estructura_json/","text":"Acc\u00e9s a Dades 5.1 - Estructura JSON Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veja'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes, que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames ****, que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.1 - Estructura JSON"},{"location":"AD_T3_Fitxers_de_diferents_formats/51__estructura_json/#51-estructura-json","text":"Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veja'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes, que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames ****, que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.1 - Estructura JSON"},{"location":"AD_T3_Fitxers_de_diferents_formats/521__lectura/","text":"Acc\u00e9s a Dades 5.2.1 - Lectura JSONTokener El primer que haurem de fer ser\u00e0 analitzar el document per a obtenir l'element arrel (que com hem vist normalment ser\u00e0 un objecte, per\u00f2 de vegades pot ser un array). El constructor de JSONTokener admet un String , amb la qual cosa analitzarem una cadena que posem directament, o tamb\u00e9 un InputStream o un Reader , amb la qual cosa podrem analitzar directament el contingut d'un fitxer El m\u00e8tode nextValue() de JSONTokener tornar\u00e0 l'arrel del document Json, i nom\u00e9s haurem de fer un cast a l'ojecte que \u00e9s l'arrel: un JSONObject o un JSONArray En el seg\u00fcent exemple agafem el json directament d'un string , on ten\u00edem els n\u00fameros parells. { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } Observeu com per a la definici\u00f3 del String ens ha tocat escapar les dobles cometes. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_11_JSONAnalitzarCadena.kt package exemples import org.json.JSONTokener import org.json.JSONObject fun main(args: Array<String>) { val cadena = \"{ \\\"p1\\\" : 2 , \\\"p2\\\" : 4 , \\\"p3\\\" : 6 , \\\"p4\\\" : 8 , \\\"p5\\\" : 10 }\" val arrel = JSONTokener(cadena).nextValue() as JSONObject println(arrel.get(\"p1\")) } Mentre que en aquest exemple accedim al fitxer parelles.json (que assumirem que t\u00e9 el mateix contingut). Podr\u00edem passar el contingut del fitxer a una cadena, per\u00f2 \u00e9s molt m\u00e9s c\u00f2mode passar el Reader com par\u00e0metre en el constructor, i ell s'encarrega de llegir-lo tot. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_12_JSONAnalitzarFitxer.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"parelles.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject println(arrel.get(\"p3\")); } JSONObject Contindr\u00e0 un objecte json . Recordeu que l' objecte es delimita amb les claus: { } El m\u00e8tode m\u00e9s important ser\u00e0 get( clau ) al qual li passem la clau del membre que volem obtenir. Si el membre \u00e9s una parella clau-valor, obtindrem directament el valor. Si \u00e9s un altre objecte, doncs obtindrem l'objecte o tamb\u00e9 podria ser un array. El cas que siga una parella clau-valor, ja l'hem vist en l'exemple anterior. En el seg\u00fcent exemple, en el fitxer Empleat.json tindrem un empleat { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } Observeu com ara de l'element arrel hem d'agafar empleat , que \u00e9s un objecte amb les parelles clau-valor num , nom , .... Copieu el seg\u00faent codi en el fitxer Kotlin Exemple_3_5_13_JSONAnalitzarEmpleat.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empleat.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empleat = arrel.get(\"empleat\") as JSONObject println(\"\" + empleat.get(\"nom\") + \" (\" + empleat.get(\"sou\") + \")\") } Tamb\u00e9 podem utilitzar els m\u00e8todes getJSONObject() , getJSONArray , getInt() , getString() , ..., que directament ens ho d\u00f3na en el tipus especificat, i no cal fer cast. JSONArray Ser\u00e0 l'array, que recordem que ve limitat per els claud\u00e0tors: [ ] Per a obtenir els elements de l'array utilitzarem el m\u00e8tode get( index ) , on l'\u00edndex \u00e9s el n\u00famero d'ordre de l'element que volem obtenir. Tamb\u00e9 tindrem els m\u00e8todes getJSONObject( index ) , getJSONArray( index ) , getInt( index ) , ..., que tornen directament el tipus especificat Posem el primer exemple sobre un json que nom\u00e9s t\u00e9 un array els elements del qual s\u00f3n valors: [ 5 , 7 , 8 , 7 ] Observeu com ara l'arrel \u00e9s un Array, i ens muntem un bucle per obtenir tots els elements. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_14_JSONAnalitzarArray.kt package exemples import org.json.JSONTokener import org.json.JSONArray fun main(args: Array<String>) { val cadena = \"[ 5 , 7 , 8 , 7 ]\" val arrel = JSONTokener(cadena).nextValue() as JSONArray for (i in arrel) println(i) } Com veieu podem fer servir els bucles foreach, per\u00f2 lamentablement no podem obtenir directament un JsonObject, i per tant l'hem de reconvertir. Ho mostrarem en el seg\u00fcent exemple en el qual agafem tots els empleats de l'empresa, on Empresa.json \u00e9s aix\u00ed: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic membre empleat que \u00e9s un array amb 4 elements, cadascun dels empleats. Copieu el seg\u00fcent exemple en el fitxer kotlin Exemple_3_5_15_JSONAnalitzarEmpresa.kt package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empresa.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empresa = arrel.getJSONObject(\"empresa\") for (e in empresa.getJSONArray(\"empleats\")){ val emp = e as JSONObject println(\"\" + emp.get(\"nom\") + \" (\" + emp.get(\"sou\") + \")\") } } Mireu com ens hem estalviat un pas, i no hem definit la variable empleats , sin\u00f3 que ho especifiquem en el bucle. Tamb\u00e9 podr\u00edem haver estalviat la variable empresa si en el bucle hagu\u00e9rem posat : for (e in arrel.getJSONObject(\"empresa\").getJSONArray(\"empleats\")){ Exemple m\u00e9s complet Mirem algun exemple ja m\u00e9s elaborat, on ens tocar\u00e0 analitzar amb detall l'estructura json. Fem-lo sobre l'exemple de BICICAS . Podeu tornar a fer la consulta de l'estat actual en aquest moment a la p\u00e0gina http://gestiona.bicicas.es/apps/apps.php , seleccionar-ho tot i guardar-lo en el fitxer Bicicas.json . \u00c9s molt possible que tinguem problemes amb els car\u00e0cers especials, com les vocals accentuades, a causa de que el navegador utilitzat no les reconega, i en copiar-les al fitxer no tinguem ja la codificaci\u00f3 correcta. No li donarem import\u00e0ncia en aquest moment. Recordem ac\u00ed l'estructura: [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podem observar, comen\u00e7a per un array , no per un objecte, com sol ser habitual. L'\u00fanic que ens interessa \u00e9s el primer element de l'array, ja que en posteriors anirien en tot cas missatges. El primer element \u00e9s un objecte que t\u00e9 un \u00fanic membre ocupacion (o si en t\u00e9 m\u00e9s no ens interessen), que \u00e9s un array amb totes les estacions. Cada estaci\u00f3 \u00e9s un objecte amb la informaci\u00f3 que ens interessa. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_16_JSONAnalitzarBicicas.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") for (e in estacions){ val est = e as JSONObject println(\"\" + e.get(\"id\") + \".- \" + e.get(\"punto\") + \" (\" + e.get(\"ocupados\") + \"/\" + e.get(\"puestos\") + \")\") } } Hem agafat l'array, d'ell hem agafat el primer objecte i d'ell l'array. I hem utilitzat un bucle for , per a tots els valors de l'array Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.2.1 - Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/521__lectura/#521-lectura","text":"JSONTokener El primer que haurem de fer ser\u00e0 analitzar el document per a obtenir l'element arrel (que com hem vist normalment ser\u00e0 un objecte, per\u00f2 de vegades pot ser un array). El constructor de JSONTokener admet un String , amb la qual cosa analitzarem una cadena que posem directament, o tamb\u00e9 un InputStream o un Reader , amb la qual cosa podrem analitzar directament el contingut d'un fitxer El m\u00e8tode nextValue() de JSONTokener tornar\u00e0 l'arrel del document Json, i nom\u00e9s haurem de fer un cast a l'ojecte que \u00e9s l'arrel: un JSONObject o un JSONArray En el seg\u00fcent exemple agafem el json directament d'un string , on ten\u00edem els n\u00fameros parells. { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } Observeu com per a la definici\u00f3 del String ens ha tocat escapar les dobles cometes. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_11_JSONAnalitzarCadena.kt package exemples import org.json.JSONTokener import org.json.JSONObject fun main(args: Array<String>) { val cadena = \"{ \\\"p1\\\" : 2 , \\\"p2\\\" : 4 , \\\"p3\\\" : 6 , \\\"p4\\\" : 8 , \\\"p5\\\" : 10 }\" val arrel = JSONTokener(cadena).nextValue() as JSONObject println(arrel.get(\"p1\")) } Mentre que en aquest exemple accedim al fitxer parelles.json (que assumirem que t\u00e9 el mateix contingut). Podr\u00edem passar el contingut del fitxer a una cadena, per\u00f2 \u00e9s molt m\u00e9s c\u00f2mode passar el Reader com par\u00e0metre en el constructor, i ell s'encarrega de llegir-lo tot. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_12_JSONAnalitzarFitxer.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"parelles.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject println(arrel.get(\"p3\")); } JSONObject Contindr\u00e0 un objecte json . Recordeu que l' objecte es delimita amb les claus: { } El m\u00e8tode m\u00e9s important ser\u00e0 get( clau ) al qual li passem la clau del membre que volem obtenir. Si el membre \u00e9s una parella clau-valor, obtindrem directament el valor. Si \u00e9s un altre objecte, doncs obtindrem l'objecte o tamb\u00e9 podria ser un array. El cas que siga una parella clau-valor, ja l'hem vist en l'exemple anterior. En el seg\u00fcent exemple, en el fitxer Empleat.json tindrem un empleat { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } Observeu com ara de l'element arrel hem d'agafar empleat , que \u00e9s un objecte amb les parelles clau-valor num , nom , .... Copieu el seg\u00faent codi en el fitxer Kotlin Exemple_3_5_13_JSONAnalitzarEmpleat.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empleat.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empleat = arrel.get(\"empleat\") as JSONObject println(\"\" + empleat.get(\"nom\") + \" (\" + empleat.get(\"sou\") + \")\") } Tamb\u00e9 podem utilitzar els m\u00e8todes getJSONObject() , getJSONArray , getInt() , getString() , ..., que directament ens ho d\u00f3na en el tipus especificat, i no cal fer cast. JSONArray Ser\u00e0 l'array, que recordem que ve limitat per els claud\u00e0tors: [ ] Per a obtenir els elements de l'array utilitzarem el m\u00e8tode get( index ) , on l'\u00edndex \u00e9s el n\u00famero d'ordre de l'element que volem obtenir. Tamb\u00e9 tindrem els m\u00e8todes getJSONObject( index ) , getJSONArray( index ) , getInt( index ) , ..., que tornen directament el tipus especificat Posem el primer exemple sobre un json que nom\u00e9s t\u00e9 un array els elements del qual s\u00f3n valors: [ 5 , 7 , 8 , 7 ] Observeu com ara l'arrel \u00e9s un Array, i ens muntem un bucle per obtenir tots els elements. Copieu el seg\u00fcent codi en el fitxer Exemple_3_5_14_JSONAnalitzarArray.kt package exemples import org.json.JSONTokener import org.json.JSONArray fun main(args: Array<String>) { val cadena = \"[ 5 , 7 , 8 , 7 ]\" val arrel = JSONTokener(cadena).nextValue() as JSONArray for (i in arrel) println(i) } Com veieu podem fer servir els bucles foreach, per\u00f2 lamentablement no podem obtenir directament un JsonObject, i per tant l'hem de reconvertir. Ho mostrarem en el seg\u00fcent exemple en el qual agafem tots els empleats de l'empresa, on Empresa.json \u00e9s aix\u00ed: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic membre empleat que \u00e9s un array amb 4 elements, cadascun dels empleats. Copieu el seg\u00fcent exemple en el fitxer kotlin Exemple_3_5_15_JSONAnalitzarEmpresa.kt package exemples import org.json.JSONTokener import org.json.JSONObject import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Empresa.json\") val arrel = JSONTokener(r_json).nextValue() as JSONObject val empresa = arrel.getJSONObject(\"empresa\") for (e in empresa.getJSONArray(\"empleats\")){ val emp = e as JSONObject println(\"\" + emp.get(\"nom\") + \" (\" + emp.get(\"sou\") + \")\") } } Mireu com ens hem estalviat un pas, i no hem definit la variable empleats , sin\u00f3 que ho especifiquem en el bucle. Tamb\u00e9 podr\u00edem haver estalviat la variable empresa si en el bucle hagu\u00e9rem posat : for (e in arrel.getJSONObject(\"empresa\").getJSONArray(\"empleats\")){ Exemple m\u00e9s complet Mirem algun exemple ja m\u00e9s elaborat, on ens tocar\u00e0 analitzar amb detall l'estructura json. Fem-lo sobre l'exemple de BICICAS . Podeu tornar a fer la consulta de l'estat actual en aquest moment a la p\u00e0gina http://gestiona.bicicas.es/apps/apps.php , seleccionar-ho tot i guardar-lo en el fitxer Bicicas.json . \u00c9s molt possible que tinguem problemes amb els car\u00e0cers especials, com les vocals accentuades, a causa de que el navegador utilitzat no les reconega, i en copiar-les al fitxer no tinguem ja la codificaci\u00f3 correcta. No li donarem import\u00e0ncia en aquest moment. Recordem ac\u00ed l'estructura: [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podem observar, comen\u00e7a per un array , no per un objecte, com sol ser habitual. L'\u00fanic que ens interessa \u00e9s el primer element de l'array, ja que en posteriors anirien en tot cas missatges. El primer element \u00e9s un objecte que t\u00e9 un \u00fanic membre ocupacion (o si en t\u00e9 m\u00e9s no ens interessen), que \u00e9s un array amb totes les estacions. Cada estaci\u00f3 \u00e9s un objecte amb la informaci\u00f3 que ens interessa. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_16_JSONAnalitzarBicicas.kt : package exemples import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") for (e in estacions){ val est = e as JSONObject println(\"\" + e.get(\"id\") + \".- \" + e.get(\"punto\") + \" (\" + e.get(\"ocupados\") + \"/\" + e.get(\"puestos\") + \")\") } } Hem agafat l'array, d'ell hem agafat el primer objecte i d'ell l'array. I hem utilitzat un bucle for , per a tots els valors de l'array Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.2.1 - Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/522__escriptura/","text":"Acc\u00e9s a Dades 5.2.2 - Escriptura Ens falta veure com escriure un document JSON. \u00c9s molt f\u00e0cil anar creant l'estructura JSON. Nom\u00e9s hem de recordar la manera d'afegir al JSONObject i al JSONArray . put(\"nom\", element) per afegir un nou membre a un JSONObject put(element) per afegir un nou element a un JSONArray Nota La major part de drivers utilitzen add(element) per a afegir un element a un JSONArray, en compte de put **** Una vegada tinguem l'estructura, podrem passar-la a un string amb el m\u00e8tode toString , i la podrem guardar directament en un fitxer, per exemple. Farem m\u00e9s d'un exemple, per poder practicar. En el primer exemple generarem un JSON a partir de dades definides en el mateix programa, per mig de vectors. Intentarem generar aquest fitxer JSON: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Analitzem l'estructura. Tenim un objecte arrel, que consta d'un \u00fanic membre, empresa, que \u00e9s un objecte. Aquest objecte t\u00e9 un \u00fanic membre que \u00e9s un array. Cada element de l'array \u00e9s un objecte, i els seus membres ja s\u00f3n clau-valor. Copieu el seg\u00fcent codi en el fitxer kotlin Exemple_3_5_17_JSONEscriureEmpleats.kt : import org.json.JSONObject import org.json.JSONArray import java.io.FileWriter fun main(args: Array<String>) { val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0) val arrel = JSONObject() val empresa = JSONObject() arrel.put(\"empresa\", empresa) val empleats = JSONArray() empresa.put(\"empleat\", empleats) for (i in 0..3){ val emp = JSONObject() emp.put(\"num\", i + 1) emp.put(\"nom\", noms[i]) emp.put(\"departament\", departaments[i]) emp.put(\"edat\", edats[i]) emp.put(\"sou\", sous[i]) empleats.put(emp) } val f = FileWriter(\"Empleats.json\") f.write(arrel.toString(4)) f.close() } Hem posat en el moment de passar el JSONObject a String el par\u00e0metre 4, per a que idente en diferents linies a 4 espais. Com veureu el resultat \u00e9s quasi perfecte {\"empresa\": {\"empleat\": [ { \"num\": 1, \"sou\": 1000, \"nom\": \"Andreu\", \"edat\": 32, \"departament\": 10 }, { \"num\": 2, \"sou\": 1200, \"nom\": \"Bernat\", \"edat\": 28, \"departament\": 20 }, { \"num\": 3, \"sou\": 1100, \"nom\": \"Cl\u00e0udia\", \"edat\": 26, \"departament\": 10 }, { \"num\": 4, \"sou\": 1500, \"nom\": \"Dami\u00e0\", \"edat\": 40, \"departament\": 10 } ]}} Tenim el problema aparent que els membres de cada empleat estan desordenats . No \u00e9s que haja eixit malament, perqu\u00e8 hem de recordar que un objecte JSON \u00e9s un conjunt no ordenat de membres. Exemple BICICAS Un altre exemple, el de Bicicas , i el que farem per a practicar tant la lectura com l'escriptura, ser\u00e0 donar-li una altra estructura. Per tant llegirem l'original, i anirem construint la seg\u00fcent estructura en qu\u00e8 est\u00e0 la informaci\u00f3 m\u00e9s resumida: { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda les estacions d'origen, i per una altra les de dest\u00ed . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_18_JSONEscriureBicicas.kt : import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader import java.io.FileWriter fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") val destEstacions = JSONArray() for (e in estacions){ e as JSONObject val destE = JSONObject(); destE.put(\"num\", e.get(\"id\")); destE.put(\"nom\", e.get(\"punto\")); destE.put(\"llocs\", e.get(\"puestos\")); destE.put(\"ocupats\", e.get(\"ocupados\")); val lliures = e.get(\"puestos\") as Int - e.get(\"ocupados\") as Int destE.put(\"lliures\", lliures) destEstacions.put(destE) } val bicicas = JSONObject() bicicas.put(\"bicicas\", destEstacions) val w_json = FileWriter(\"Bicicas2.json\"); w_json.write(bicicas.toString(4)); w_json.close(); } El resultat seria aquest (observeu que hav\u00edem posat una tabulaci\u00f3 de 4): {\"bicicas\": [ { \"num\": \"01\", \"ocupats\": 23, \"llocs\": 28, \"nom\": \"UJI - FCHS\", \"lliures\": 5 }, { \"num\": \"02\", \"ocupats\": 0, \"llocs\": 28, \"nom\": \"ESTACI\u00c3\u00b3N DE FERROCARRIL Y AUTOBUSES\", \"lliures\": 28 }, ... ]} Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.2.2 - Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/522__escriptura/#522-escriptura","text":"Ens falta veure com escriure un document JSON. \u00c9s molt f\u00e0cil anar creant l'estructura JSON. Nom\u00e9s hem de recordar la manera d'afegir al JSONObject i al JSONArray . put(\"nom\", element) per afegir un nou membre a un JSONObject put(element) per afegir un nou element a un JSONArray Nota La major part de drivers utilitzen add(element) per a afegir un element a un JSONArray, en compte de put **** Una vegada tinguem l'estructura, podrem passar-la a un string amb el m\u00e8tode toString , i la podrem guardar directament en un fitxer, per exemple. Farem m\u00e9s d'un exemple, per poder practicar. En el primer exemple generarem un JSON a partir de dades definides en el mateix programa, per mig de vectors. Intentarem generar aquest fitxer JSON: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Analitzem l'estructura. Tenim un objecte arrel, que consta d'un \u00fanic membre, empresa, que \u00e9s un objecte. Aquest objecte t\u00e9 un \u00fanic membre que \u00e9s un array. Cada element de l'array \u00e9s un objecte, i els seus membres ja s\u00f3n clau-valor. Copieu el seg\u00fcent codi en el fitxer kotlin Exemple_3_5_17_JSONEscriureEmpleats.kt : import org.json.JSONObject import org.json.JSONArray import java.io.FileWriter fun main(args: Array<String>) { val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf( 10, 20, 10, 10 ) val edats = arrayOf( 32, 28, 26, 40 ) val sous = arrayOf( 1000.0, 1200.0, 1100.0, 1500.0) val arrel = JSONObject() val empresa = JSONObject() arrel.put(\"empresa\", empresa) val empleats = JSONArray() empresa.put(\"empleat\", empleats) for (i in 0..3){ val emp = JSONObject() emp.put(\"num\", i + 1) emp.put(\"nom\", noms[i]) emp.put(\"departament\", departaments[i]) emp.put(\"edat\", edats[i]) emp.put(\"sou\", sous[i]) empleats.put(emp) } val f = FileWriter(\"Empleats.json\") f.write(arrel.toString(4)) f.close() } Hem posat en el moment de passar el JSONObject a String el par\u00e0metre 4, per a que idente en diferents linies a 4 espais. Com veureu el resultat \u00e9s quasi perfecte {\"empresa\": {\"empleat\": [ { \"num\": 1, \"sou\": 1000, \"nom\": \"Andreu\", \"edat\": 32, \"departament\": 10 }, { \"num\": 2, \"sou\": 1200, \"nom\": \"Bernat\", \"edat\": 28, \"departament\": 20 }, { \"num\": 3, \"sou\": 1100, \"nom\": \"Cl\u00e0udia\", \"edat\": 26, \"departament\": 10 }, { \"num\": 4, \"sou\": 1500, \"nom\": \"Dami\u00e0\", \"edat\": 40, \"departament\": 10 } ]}} Tenim el problema aparent que els membres de cada empleat estan desordenats . No \u00e9s que haja eixit malament, perqu\u00e8 hem de recordar que un objecte JSON \u00e9s un conjunt no ordenat de membres. Exemple BICICAS Un altre exemple, el de Bicicas , i el que farem per a practicar tant la lectura com l'escriptura, ser\u00e0 donar-li una altra estructura. Per tant llegirem l'original, i anirem construint la seg\u00fcent estructura en qu\u00e8 est\u00e0 la informaci\u00f3 m\u00e9s resumida: { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda les estacions d'origen, i per una altra les de dest\u00ed . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_18_JSONEscriureBicicas.kt : import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.io.FileReader import java.io.FileWriter fun main(args: Array<String>) { val r_json = FileReader(\"Bicicas.json\") val arrel = JSONTokener(r_json).nextValue() as JSONArray val estacions = arrel.getJSONObject(0).getJSONArray(\"ocupacion\") val destEstacions = JSONArray() for (e in estacions){ e as JSONObject val destE = JSONObject(); destE.put(\"num\", e.get(\"id\")); destE.put(\"nom\", e.get(\"punto\")); destE.put(\"llocs\", e.get(\"puestos\")); destE.put(\"ocupats\", e.get(\"ocupados\")); val lliures = e.get(\"puestos\") as Int - e.get(\"ocupados\") as Int destE.put(\"lliures\", lliures) destEstacions.put(destE) } val bicicas = JSONObject() bicicas.put(\"bicicas\", destEstacions) val w_json = FileWriter(\"Bicicas2.json\"); w_json.write(bicicas.toString(4)); w_json.close(); } El resultat seria aquest (observeu que hav\u00edem posat una tabulaci\u00f3 de 4): {\"bicicas\": [ { \"num\": \"01\", \"ocupats\": 23, \"llocs\": 28, \"nom\": \"UJI - FCHS\", \"lliures\": 5 }, { \"num\": \"02\", \"ocupats\": 0, \"llocs\": 28, \"nom\": \"ESTACI\u00c3\u00b3N DE FERROCARRIL Y AUTOBUSES\", \"lliures\": 28 }, ... ]} Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.2.2 - Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/52_driver_orgjson/","text":"Acc\u00e9s a Dades 5.2 Driver org.json Hi ha m\u00e9s d'una llibreria per a poder accedir i analitzar els documents json. Per exemple, es comenten prou per Internet s\u00f3n GSON (de Google) i Jackson . Per\u00f2 nosaltres anem a utilitzar dues altres llibreries Una, la del grup org.json que en principi ser\u00e0 la mateixa que s'utilitzar\u00e0 en Android Una altra, la de Moshi , que ens permetr\u00e0 elaborar m\u00e9s el resultat ja que podrem fer una conversi\u00f3 entre Json i objectes de Java o de Kotlin Pel que fa a la primera, en el moment de fer aquestos apunts l'\u00faltima versi\u00f3 estable \u00e9s la 20210307 , \u00e9s a dir, de juliol de 2018. En aquest enlla\u00e7 teniu d'on us la podeu baixar: https://jar- download.com/artifacts/org.json/json/20210307 . Una vegada baixada l'haurem d'incorporar al nostre projecte (sobre el projecte F4 -- > Modules --> pestanya dependencies --> + ) En ella trobem el m\u00e9s b\u00e0sic: JSONObject : equivaldr\u00e0 a un objecte JSONArray : equivaldr\u00e0 a un array JSONTokener :ens permetr\u00e0 analitzar el document Json, i tornar\u00e0 l'objecte arrel. El m\u00e8tode que utilitzarem ser\u00e0 sempre nextValue() . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"52 driver orgjson"},{"location":"AD_T3_Fitxers_de_diferents_formats/52_driver_orgjson/#52-driver-orgjson","text":"Hi ha m\u00e9s d'una llibreria per a poder accedir i analitzar els documents json. Per exemple, es comenten prou per Internet s\u00f3n GSON (de Google) i Jackson . Per\u00f2 nosaltres anem a utilitzar dues altres llibreries Una, la del grup org.json que en principi ser\u00e0 la mateixa que s'utilitzar\u00e0 en Android Una altra, la de Moshi , que ens permetr\u00e0 elaborar m\u00e9s el resultat ja que podrem fer una conversi\u00f3 entre Json i objectes de Java o de Kotlin Pel que fa a la primera, en el moment de fer aquestos apunts l'\u00faltima versi\u00f3 estable \u00e9s la 20210307 , \u00e9s a dir, de juliol de 2018. En aquest enlla\u00e7 teniu d'on us la podeu baixar: https://jar- download.com/artifacts/org.json/json/20210307 . Una vegada baixada l'haurem d'incorporar al nostre projecte (sobre el projecte F4 -- > Modules --> pestanya dependencies --> + ) En ella trobem el m\u00e9s b\u00e0sic: JSONObject : equivaldr\u00e0 a un objecte JSONArray : equivaldr\u00e0 a un array JSONTokener :ens permetr\u00e0 analitzar el document Json, i tornar\u00e0 l'objecte arrel. El m\u00e8tode que utilitzarem ser\u00e0 sempre nextValue() . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.2 Driver org.json"},{"location":"AD_T3_Fitxers_de_diferents_formats/531_lectura/","text":"Acc\u00e9s a Dades 5.3.1 Lectura Com coment\u00e0vem en la pregunta anterior, la llibreria Moshi permet passar d'un document JSON directament a objectes Java o Kotlin. Ho mostrarem en dos exemples: Primer per a poder llegir Empresa.json, en qu\u00e8 l'element arrel \u00e9s un objecte Json. Despr\u00e9s per a llegir Bicicas,json, en qu\u00e8 l'element arrel \u00e9s un array Json, cosa que ens complica un poc la lectura Cas 1: l'arrel \u00e9s un objecte Tant en un com en l'altre primer haurem de crear les classes Java o Kotlin on anir\u00e0 la lectura del fitxer. Aquestes classes hauran de tenir la mateixa estructura que en JSON, per\u00f2 adaptades a Java o Kotlin. Anem per tant a analitzar Empresa.json , que ja el ten\u00edem creat i tenia aquesta estructura: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tamb\u00e9 ten\u00edem creada la classe Empleat, des de la pregunta 3 d'aquest tema, i tenia aquesta estructura. Empleat.kt : class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) L'hav\u00edem fet Serializable , per\u00f2 aix\u00f2 no importa en aquest exemple. El podem deixar tal qual estava. L'estuctura del fitxer JSON, ens marca que l'arrel \u00e9s un objecte que t\u00e9 un \u00fanic membre que es diu empresa , que \u00e9s un objecte que t\u00e9 un \u00fanic membre anomenat empleats , que \u00e9s un array d'objectes (que coincideixen ja amb la classe Empleat ). Per tant ens hem de construir una classe que que tinga una propietat anomenada empleats , que siga un conjunt de Empleat . Ens vindr\u00e0 b\u00e9 un List . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empleats.kt ; class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) I a partir d'aquesta hem de construir una altra classe que tinga una \u00fanica propietat anomenada empresa que siga de tipus Empleats . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empresa.kt class Empresa(val empresa: Empleats) La lectura del fitxer la fem a partir d'un objecte Moshi al qual per mig del m\u00e8tode adapter definim quina classe volem llegir. Una vegada llegit ja podem utilitzar els objectes Java o Kotlin. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_21_MOSHIAnalitzarEmpresa.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val json = File(\"Empresa.json\").readText() val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val empresa = adapter.fromJson(json) val llEmpleats= empresa!!.empresa.empleats println(\"Hi ha \" + llEmpleats.size + \" empleats:\") for (e in llEmpleats) println(e.nom + \" (\" + e.sou +\")\") } Cas 2: l'arrel \u00e9s un array En cas que l'arrel del fitxer JSON siga un array, se'ns complica un poc, perqu\u00e8 en el moment de definir quina classe volem llegir, no \u00e9s en realitat una classe, sin\u00f3 un col\u00b7lecci\u00f3 (un List hav\u00edem vist que \u00e9s el que utilitz\u00e0vem). Moshi utilitza una t\u00e8cnica per a poder fer la lectura de l'array, que consisteix a crear-se un tipus de dades que seria la concatenaci\u00f3 d'un List i de la classe de la qual volem l'array. Ho veurem molt millor en l'exemple. L'exemple ser\u00e0 per a llegir el fitxer Bicicas.json, que recordem que comen\u00e7ava per un array: [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Era un array d'un \u00fanic element , per\u00f2 en definitiva un array. Nom\u00e9s ens interessa el primer element, que ser\u00e0 un objecte amb un \u00fanic membre anomenat ocupacion , que \u00e9s un array on cada element \u00e9s un objecte corresponent a una estaci\u00f3, amb les seues caracter\u00edstiques com a parelles clau-valor. Definim per tant la classe Estacio.kt : class Estacio( val id: Long, val punto: String, val puestos: Int, val ocupados: Int, val latitud: Double, val longitud: Double, val porcentajeAltaOcupacion: Int, val porcentajeBajaOcupacion: Int ) I la classe Estacions.kt ****: class Estacions(val ocupacion: List<Estacio> = listOf<Estacio>()) Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_22_MOSHIAnalitzarBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val bicicas = adapter.fromJson(json) val estacions = bicicas!!.get(0).ocupacion println(\"Hi ha \" + estacions.size + \" estacions:\") for (e in estacions) println(\"\" + e.id + \": \" + e.punto + \" (\" + e.ocupados + \"/\" + e.puestos + \")\") } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.3.1 Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/531_lectura/#531-lectura","text":"Com coment\u00e0vem en la pregunta anterior, la llibreria Moshi permet passar d'un document JSON directament a objectes Java o Kotlin. Ho mostrarem en dos exemples: Primer per a poder llegir Empresa.json, en qu\u00e8 l'element arrel \u00e9s un objecte Json. Despr\u00e9s per a llegir Bicicas,json, en qu\u00e8 l'element arrel \u00e9s un array Json, cosa que ens complica un poc la lectura Cas 1: l'arrel \u00e9s un objecte Tant en un com en l'altre primer haurem de crear les classes Java o Kotlin on anir\u00e0 la lectura del fitxer. Aquestes classes hauran de tenir la mateixa estructura que en JSON, per\u00f2 adaptades a Java o Kotlin. Anem per tant a analitzar Empresa.json , que ja el ten\u00edem creat i tenia aquesta estructura: { \"empresa\" : { \"empleats\": [ { \"num\":1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000.0} , { \"num\":2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200.0} , { \"num\":3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100.0} , { \"num\":4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500.0} ] } } Tamb\u00e9 ten\u00edem creada la classe Empleat, des de la pregunta 3 d'aquest tema, i tenia aquesta estructura. Empleat.kt : class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) L'hav\u00edem fet Serializable , per\u00f2 aix\u00f2 no importa en aquest exemple. El podem deixar tal qual estava. L'estuctura del fitxer JSON, ens marca que l'arrel \u00e9s un objecte que t\u00e9 un \u00fanic membre que es diu empresa , que \u00e9s un objecte que t\u00e9 un \u00fanic membre anomenat empleats , que \u00e9s un array d'objectes (que coincideixen ja amb la classe Empleat ). Per tant ens hem de construir una classe que que tinga una propietat anomenada empleats , que siga un conjunt de Empleat . Ens vindr\u00e0 b\u00e9 un List . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empleats.kt ; class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) I a partir d'aquesta hem de construir una altra classe que tinga una \u00fanica propietat anomenada empresa que siga de tipus Empleats . Com que la utilitzarem en m\u00e9s d'un exemple, la guardem en el fitxer de classe Empresa.kt class Empresa(val empresa: Empleats) La lectura del fitxer la fem a partir d'un objecte Moshi al qual per mig del m\u00e8tode adapter definim quina classe volem llegir. Una vegada llegit ja podem utilitzar els objectes Java o Kotlin. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_21_MOSHIAnalitzarEmpresa.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val json = File(\"Empresa.json\").readText() val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val empresa = adapter.fromJson(json) val llEmpleats= empresa!!.empresa.empleats println(\"Hi ha \" + llEmpleats.size + \" empleats:\") for (e in llEmpleats) println(e.nom + \" (\" + e.sou +\")\") } Cas 2: l'arrel \u00e9s un array En cas que l'arrel del fitxer JSON siga un array, se'ns complica un poc, perqu\u00e8 en el moment de definir quina classe volem llegir, no \u00e9s en realitat una classe, sin\u00f3 un col\u00b7lecci\u00f3 (un List hav\u00edem vist que \u00e9s el que utilitz\u00e0vem). Moshi utilitza una t\u00e8cnica per a poder fer la lectura de l'array, que consisteix a crear-se un tipus de dades que seria la concatenaci\u00f3 d'un List i de la classe de la qual volem l'array. Ho veurem molt millor en l'exemple. L'exemple ser\u00e0 per a llegir el fitxer Bicicas.json, que recordem que comen\u00e7ava per un array: [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":28,\"ocupados\":11,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":28,\"ocupados\":8,\"latitud\":\"39.98765\", \"longitud\":\"-0.05281\",\"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":13,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Era un array d'un \u00fanic element , per\u00f2 en definitiva un array. Nom\u00e9s ens interessa el primer element, que ser\u00e0 un objecte amb un \u00fanic membre anomenat ocupacion , que \u00e9s un array on cada element \u00e9s un objecte corresponent a una estaci\u00f3, amb les seues caracter\u00edstiques com a parelles clau-valor. Definim per tant la classe Estacio.kt : class Estacio( val id: Long, val punto: String, val puestos: Int, val ocupados: Int, val latitud: Double, val longitud: Double, val porcentajeAltaOcupacion: Int, val porcentajeBajaOcupacion: Int ) I la classe Estacions.kt ****: class Estacions(val ocupacion: List<Estacio> = listOf<Estacio>()) Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_22_MOSHIAnalitzarBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val bicicas = adapter.fromJson(json) val estacions = bicicas!!.get(0).ocupacion println(\"Hi ha \" + estacions.size + \" estacions:\") for (e in estacions) println(\"\" + e.id + \": \" + e.punto + \" (\" + e.ocupados + \"/\" + e.puestos + \")\") } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.3.1 Lectura"},{"location":"AD_T3_Fitxers_de_diferents_formats/532_escriptura/","text":"Acc\u00e9s a Dades 5.3.2 Escriptura Tamb\u00e9 farem 2 exemples d'escriptura, el d'Empleats i el de Bicicas, els mateixos que en la pregunta 5.2.2 Cas 1: Empleats Per a Empleats.json aquest \u00e9s l'estructura que volem aconseguir: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } L'estructura de les classes ser\u00e0 la mateixa que en el cas de la lectura, per\u00f2 ara les dades estaran definides en 4 arrays. A partir dels arrays inicialitzarem els objectes Kotlin, i quan ho tinguem tot ple passarem a JSON. NO HEM DE DEFINIR LES CLASSES, ja que les tenim definides des punt 5.3.1. Les posem ac\u00ed \u00fanicament per a il\u00b7lustrar: class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) class Empresa(val empresa: Empleats) Aleshores, inicialitzem els objectes a partir de les dades que tenim en els 4 arrays, i despr\u00e9s guardem en JSON. Mireu que la definici\u00f3 de les classes de Moshi \u00e9s la mateixa, per\u00f2 ara utilitzem el m\u00e8tode toJson() per a passar d'objectes Kotlin a JSON. Obtenim un String que \u00e9s la cadena JSON, i senzillament l'escrivim en un fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_23_MOSHIEscriureEmpleats.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) val empleats = arrayListOf<Empleat>() for (i in 0..3) empleats.add(Empleat((i+1),noms[i],departaments[i],edats[i],sous[i])) val empresa = Empresa(Empleats(empleats)) val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val json = adapter.toJson(empresa) File(\"Empleats2.json\").writeText(json) } Cas 2: Bicicas Farem el mateix exercici que en l'apartat 5.2.2, per\u00f2 ara utilitzant la llibreria Moshi . Voldrem aconseguir aquesta estructura i guardar-la en el fitxer { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda l'estructura d'origen, per a la qual utilitzem les classes ja definides en l'apartat 5.3.1, \u00e9s a dir, per a llegir el fitxer Bicicas.json original fem el mateix que l'altra vegada, per tant ser\u00e0 copiar les primeres sent\u00e8ncies del programa Exemple_3_5_22_MOSHIAnalitzarBicicas.kt . A partir dels objectes inicialitzats amb la lectura de Bicicas.json, construirem els objectes que ens serviran per a l'escriptura. L'estructura d'aquestes classes que ens serviran per a l'escriptura seran: class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) Per comoditat, com que nom\u00e9s anem a utilitzar-les en aquesta ocasi\u00f3, les definirem en el mateix fitxer del programa. Observeu com senzillament llegim passant a les classes d'entrada, convertim a les classes d'eixida, i utilitzem aquestes \u00faltimes per escriure el fitxer. Copieu el seg\u00fcent codi en el fitxer Kotlin anomenat Exemple_3_5_24_MOSHIEscriureBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() val bicicas2 = Bicicas2(llistaEstDesti) for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val adapter2 = moshi.adapter(Bicicas2::class.java) val json2 = adapter2.toJson(bicicas2) File(\"Bicicas2.json\").writeText(json2) } Segurament aquesta estructura \u00e9s la m\u00e9s coherent. Amb la finalitat \u00fanicament d'escriure un JSON que t\u00e9 com a arrel un array i no un objecte, anem a ferun altre exemple en el qual guardarem en un fitxer aquesta estructura: [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] En aquesta ocasi\u00f3 tenim nom\u00e9s un array d'objectes. L'\u00fanica estructura d'eixida que ens cal \u00e9s la classe EstDesti , ja definida en l'exercici anterior, i per tant ara no caldr\u00e0 definir-la. Nom\u00e9s hem d'anar amb compte amb l'estructura d'eixida, que ara no ser\u00e0 una classe sin\u00f3 una combinaci\u00f3 de List i EstDesti . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_25_MOSHIEscriureBicicas3.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val llistaTipusDesti = Types.newParameterizedType(List::class.java, EstDesti::class.java) val adapter2: JsonAdapter<List<EstDesti>> = moshi.adapter(llistaTipusDesti) val json2 = adapter2.toJson(llistaEstDesti) File(\"Bicicas3.json\").writeText(json2) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.3.2 Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/532_escriptura/#532-escriptura","text":"Tamb\u00e9 farem 2 exemples d'escriptura, el d'Empleats i el de Bicicas, els mateixos que en la pregunta 5.2.2 Cas 1: Empleats Per a Empleats.json aquest \u00e9s l'estructura que volem aconseguir: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } L'estructura de les classes ser\u00e0 la mateixa que en el cas de la lectura, per\u00f2 ara les dades estaran definides en 4 arrays. A partir dels arrays inicialitzarem els objectes Kotlin, i quan ho tinguem tot ple passarem a JSON. NO HEM DE DEFINIR LES CLASSES, ja que les tenim definides des punt 5.3.1. Les posem ac\u00ed \u00fanicament per a il\u00b7lustrar: class Empleat (var num: Int, var nom: String, var departament: Int, var edat: Int, var sou: Double) class Empleats(val empleats: List<Empleat> = listOf<Empleat>()) class Empresa(val empresa: Empleats) Aleshores, inicialitzem els objectes a partir de les dades que tenim en els 4 arrays, i despr\u00e9s guardem en JSON. Mireu que la definici\u00f3 de les classes de Moshi \u00e9s la mateixa, per\u00f2 ara utilitzem el m\u00e8tode toJson() per a passar d'objectes Kotlin a JSON. Obtenim un String que \u00e9s la cadena JSON, i senzillament l'escrivim en un fitxer. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Exemple_3_5_23_MOSHIEscriureEmpleats.kt : package exemples import com.squareup.moshi.* import java.io.File fun main (args: Array<String>){ val noms = arrayOf(\"Andreu\", \"Bernat\", \"Cl\u00e0udia\", \"Dami\u00e0\") val departaments = arrayOf(10, 20, 10, 10) val edats = arrayOf(32, 28, 26, 40) val sous = arrayOf(1000.0, 1200.0, 1100.0, 1500.0) val empleats = arrayListOf<Empleat>() for (i in 0..3) empleats.add(Empleat((i+1),noms[i],departaments[i],edats[i],sous[i])) val empresa = Empresa(Empleats(empleats)) val moshi = Moshi.Builder().build() val adapter = moshi.adapter(Empresa::class.java) val json = adapter.toJson(empresa) File(\"Empleats2.json\").writeText(json) } Cas 2: Bicicas Farem el mateix exercici que en l'apartat 5.2.2, per\u00f2 ara utilitzant la llibreria Moshi . Voldrem aconseguir aquesta estructura i guardar-la en el fitxer { \"bicicas\": [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] } Tindrem per una banda l'estructura d'origen, per a la qual utilitzem les classes ja definides en l'apartat 5.3.1, \u00e9s a dir, per a llegir el fitxer Bicicas.json original fem el mateix que l'altra vegada, per tant ser\u00e0 copiar les primeres sent\u00e8ncies del programa Exemple_3_5_22_MOSHIAnalitzarBicicas.kt . A partir dels objectes inicialitzats amb la lectura de Bicicas.json, construirem els objectes que ens serviran per a l'escriptura. L'estructura d'aquestes classes que ens serviran per a l'escriptura seran: class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) Per comoditat, com que nom\u00e9s anem a utilitzar-les en aquesta ocasi\u00f3, les definirem en el mateix fitxer del programa. Observeu com senzillament llegim passant a les classes d'entrada, convertim a les classes d'eixida, i utilitzem aquestes \u00faltimes per escriure el fitxer. Copieu el seg\u00fcent codi en el fitxer Kotlin anomenat Exemple_3_5_24_MOSHIEscriureBicicas.kt : package exemples import com.squareup.moshi.* import java.io.File class EstDesti (val num: Int, val nom: String, val llocs: Int, val ocupats: Int, val lliures: Int) class Bicicas2 (val bicicas: List<EstDesti>) fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() val bicicas2 = Bicicas2(llistaEstDesti) for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val adapter2 = moshi.adapter(Bicicas2::class.java) val json2 = adapter2.toJson(bicicas2) File(\"Bicicas2.json\").writeText(json2) } Segurament aquesta estructura \u00e9s la m\u00e9s coherent. Amb la finalitat \u00fanicament d'escriure un JSON que t\u00e9 com a arrel un array i no un objecte, anem a ferun altre exemple en el qual guardarem en un fitxer aquesta estructura: [ {\"num\":\"01\",\"nom\":\"UJI - FCHS\",\"llocs\":28,\"ocupats\":11,\"lliures\":17}, {\"num\":\"02\",\"nom\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"llocs\":28,\"ocupats\":8,\"lliures\":20}, {\"num\":\"03\",\"nom\":\"PLAZA DE PESCADER\u00cdA\",\"llocs\":28,\"ocupats\":13,\"lliures\":15}, ... ] En aquesta ocasi\u00f3 tenim nom\u00e9s un array d'objectes. L'\u00fanica estructura d'eixida que ens cal \u00e9s la classe EstDesti , ja definida en l'exercici anterior, i per tant ara no caldr\u00e0 definir-la. Nom\u00e9s hem d'anar amb compte amb l'estructura d'eixida, que ara no ser\u00e0 una classe sin\u00f3 una combinaci\u00f3 de List i EstDesti . Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_3_5_25_MOSHIEscriureBicicas3.kt : package exemples import com.squareup.moshi.* import java.io.File fun main(args: Array<String>) { val json = File(\"Bicicas.json\").readText() val moshi = Moshi.Builder().build() val llistaTipus = Types.newParameterizedType(List::class.java, Estacions::class.java) val adapter: JsonAdapter<List<Estacions>> = moshi.adapter(llistaTipus) val estacions = adapter.fromJson(json).get(0).ocupacion val llistaEstDesti = arrayListOf<EstDesti>() for (e in estacions) llistaEstDesti.add(EstDesti(e.id.toInt(),e.punto,e.puestos,e.ocupados,e.puestos-e.ocupados)) val llistaTipusDesti = Types.newParameterizedType(List::class.java, EstDesti::class.java) val adapter2: JsonAdapter<List<EstDesti>> = moshi.adapter(llistaTipusDesti) val json2 = adapter2.toJson(llistaEstDesti) File(\"Bicicas3.json\").writeText(json2) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.3.2 Escriptura"},{"location":"AD_T3_Fitxers_de_diferents_formats/53_driver_moshi/","text":"Acc\u00e9s a Dades 5.3 Driver Moshi El driver anterior tenia un funcionament molt senzill, per\u00f2 que obliga a seguir en tot moment l'estructura que t\u00e9 el fitxer Json, buscar entre els objectes i arrays cada vegada que es fa un acc\u00e9s. Si s\u00f3n relativament pocs els accessos, \u00e9s molt c\u00f2mode, per\u00f2 si s'ha de fer un acc\u00e9s continuat pot resultar m\u00e9s pesat. Existeix una altra llibreria, que ens permet passar d'un fitxer Json a objectes de Java o Kotlin, la qual cosa ens anir\u00e0 b\u00e9 quan siguen molts els accessos, perqu\u00e8 en definitiva tindrem les dades en l'entorn natural del nostre llenguatge: els objectes. Es tracta de la llibreria MOSHI , i aquest \u00e9s el lloc on poder trobar-la: https://github.com/square/moshi En el moment de fer aquestos apunts, va per la versi\u00f3 1.14.0. Tanmateix en les \u00faltimes versions d\u00f3na un error de compatibilitat. Ens conformarem per tant amb una versi\u00f3 anterior. Podem trobar totes les versions en aquest enlla\u00e7: https://jar-download.com/artifacts/com.squareup.moshi/moshi Podem agafar per exemple versi\u00f3 1.8.0: https://jar-download.com/artifacts/com.squareup.moshi/moshi/1.8.0/source- code Veureu que hi ha dos drivers, el propi de Moshi i un altre driver anomenat okio . Haurem d'incorporar els dos al nostre projecte. Recordeu que la manera d'incorporar els drivers al projecte IntelliJ \u00e9s amb: Sobre el projecte F4 (Project Structure) -- > Modules --> pestanya dependencies --> + Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"53 driver moshi"},{"location":"AD_T3_Fitxers_de_diferents_formats/53_driver_moshi/#53-driver-moshi","text":"El driver anterior tenia un funcionament molt senzill, per\u00f2 que obliga a seguir en tot moment l'estructura que t\u00e9 el fitxer Json, buscar entre els objectes i arrays cada vegada que es fa un acc\u00e9s. Si s\u00f3n relativament pocs els accessos, \u00e9s molt c\u00f2mode, per\u00f2 si s'ha de fer un acc\u00e9s continuat pot resultar m\u00e9s pesat. Existeix una altra llibreria, que ens permet passar d'un fitxer Json a objectes de Java o Kotlin, la qual cosa ens anir\u00e0 b\u00e9 quan siguen molts els accessos, perqu\u00e8 en definitiva tindrem les dades en l'entorn natural del nostre llenguatge: els objectes. Es tracta de la llibreria MOSHI , i aquest \u00e9s el lloc on poder trobar-la: https://github.com/square/moshi En el moment de fer aquestos apunts, va per la versi\u00f3 1.14.0. Tanmateix en les \u00faltimes versions d\u00f3na un error de compatibilitat. Ens conformarem per tant amb una versi\u00f3 anterior. Podem trobar totes les versions en aquest enlla\u00e7: https://jar-download.com/artifacts/com.squareup.moshi/moshi Podem agafar per exemple versi\u00f3 1.8.0: https://jar-download.com/artifacts/com.squareup.moshi/moshi/1.8.0/source- code Veureu que hi ha dos drivers, el propi de Moshi i un altre driver anomenat okio . Haurem d'incorporar els dos al nostre projecte. Recordeu que la manera d'incorporar els drivers al projecte IntelliJ \u00e9s amb: Sobre el projecte F4 (Project Structure) -- > Modules --> pestanya dependencies --> + Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.3 Driver Moshi"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/","text":"Acc\u00e9s a Dades 5.- Documents JSON JSON vol dir J ava S cript O bject N otation , \u00e9s a dir Notaci\u00f3 d'Objectes de JavaScript. \u00c9s una manera de representar objectes inicialment per a JavaScript, per\u00f2 per la seua senzillesa, i com \u00e9s en text pla, serveix per a qualsevol entorn. Permet representar estructures de dades d'una determinada complexitat, com el XML, per\u00f2 pesa molt menys que aquest, i per aix\u00f2 est\u00e0 convertint-se en un est\u00e0ndar d'intercanvi de dades, sobretot entre un servidor i una aplicaci\u00f3 web. L'extensi\u00f3 d'un fitxer JSON \u00e9s .json Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5 documents json"},{"location":"AD_T3_Fitxers_de_diferents_formats/5_documents_json/#5-documents-json","text":"JSON vol dir J ava S cript O bject N otation , \u00e9s a dir Notaci\u00f3 d'Objectes de JavaScript. \u00c9s una manera de representar objectes inicialment per a JavaScript, per\u00f2 per la seua senzillesa, i com \u00e9s en text pla, serveix per a qualsevol entorn. Permet representar estructures de dades d'una determinada complexitat, com el XML, per\u00f2 pesa molt menys que aquest, i per aix\u00f2 est\u00e0 convertint-se en un est\u00e0ndar d'intercanvi de dades, sobretot entre un servidor i una aplicaci\u00f3 web. L'extensi\u00f3 d'un fitxer JSON \u00e9s .json Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.- Documents JSON"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/","text":"Acc\u00e9s a Dades Exercicis Exercici 3_1 En el projecte anomenat Tema3 , crea't un paquet anomenat exercicis on col\u00b7locarem tot el relatiu als exercicis d'aquest tema. Copia't dins del projecte el fitxer Rutes.dat que us passar\u00e0 el professor. En ell tenim dades pr\u00e8viament guardades que seran unes rutes consistents en una s\u00e8rie de punts amb una descripci\u00f3. Cada punt seran unes coordenades (com en un mapa). L'estructura de les dades guardades \u00e9s la seg\u00fcent nom de la ruta (string) desnivell (int) desnivell acumulat (int) n\u00famero de punts (int) Per cada punt: nom (string) latitud (double) longitud (double) Observa que la quarta dada \u00e9s un enter amb el n\u00famero de punts de la ruta. Fes un programa (amb fun main() ) en el fitxer Kotlin Ex3_1_LlegirRutesSerial.kt que agafe les dades del fitxer (hi ha 2 rutes, per\u00f2 ho heu de fer gen\u00e8ric per a un n\u00famero indeterminat de rutes) i les traga per pantalla amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) Ruta: La Magdalena Desnivell: 51 Desnivell acumulat: 84 T\u00e9 7 punts Punt 1: Primer Mol\u00ed (39.99385,-0.032941) Punt 2: Segon Mol\u00ed (39.99628,-0.029427) Punt 3: Camin\u00e0s (40.00513,-0.022569) Punt 4: Riu Sec (40.006765,-0.02237) Punt 5: Sant Roc (40.017906,-0.02289) Punt 6: Explanada (40.034048,-0.00633) Punt 7: La Magdalena (40.034519,-0.005856) Exercici 3_2 ****Construeix les seg\u00fcents classes: Coordenades , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar- li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: latitud (double) longitud (double) No caldr\u00e0 contructor, ni getters ni setters, ja que Kotlin els genera autom\u00e0ticament PuntGeo , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar-li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: nom (String) coord (Coordenades) Ruta . Aquesta classe us la passar\u00e0 el professor. Tamb\u00e9 implementa Serializable i cont\u00e9: nom (String)**** desnivell (int) desnivellAcumulat (int) llistaDePunts : un ArrayList de PuntGeo Observa com per a m\u00e9s comoditat t\u00e9 els m\u00e8todes: addPunt(PuntGeo) , que afegir\u00e0 un nou PuntGeo a la llista getPunt(int) , al qual se li passa l'\u00edndex del punt que es vol i torna tot aquest punt getPuntNom(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 el seu nom getPuntLatitud(int) ****, al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua latitud getPuntLongitud(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua longitud size() , que ens d\u00f3na el n\u00famero de punts guardats en la llista. L'\u00fanic que has de fer en aquesta classe \u00e9s: Fes un m\u00e8tode nou en la classe Ruta anomenat mostraRuta() , que mostre el contingut de la ruta amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell Acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) En un fitxer Kotlin anomenat Ex3_2_PassarRutesSerialObj.kt , fes el programa que passe del fitxe Rutes.dat al fitxer Rutes.obj . \u00c9s a dir, has d'anar agafant la informaci\u00f3 del fitxer Rutes.dat , guardar la informaci\u00f3 en un objecte Ruta , visualitzar la seua informaci\u00f3 amb mostraRuta() i per \u00faltim guardar la informaci\u00f3 de l'objecte en un fitxer anomenat Rutes.obj . I aix\u00f2 fins el final de fitxer (hi ha 2 rutes) En un fitxer Kotlin anomenat Ex3_2_LlegirRutesObj.kt , llig les rutes guardades en el fitxer Rutes.obj i mostra-les per pantalla utilitzant el m\u00e8tode mostraRuta() Exercici 3_3 Fes un programa en el fitxer Ex3_3_PassarRutesObjXML.kt (amb main) que passe el fitxer Rutes.obj a un fitxer XML anomenat Rutes.xml amb aquest aspecte. Els punts suspensius indiquen que hi ha m\u00e9s d'un punt en cada ruta, i que hi ha m\u00e9s d'una ruta Pujada a Penyagolosa 530 530 Sant Joan ... ... ... ... Exercici 3_4 Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.xml per a que apareguen els noms de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas ens conv\u00e9 getSelectedIndex() , ja que el n\u00famero d'ordre de l'element seleccionat ser\u00e0 el mateix que el n\u00famero d'ordre de la ruta que busquem en el NodeList doc.getElementsByTagName(\"ruta\") L'esquelet del programa seria aquest. Copieu-lo en un fitxer Kotlin anomenat Ex3_4_VisRutesXML.kt : import javax.swing.* import java.awt.* import org.w3c.dom.Document import org.w3c.dom.Element import javax.xml.parsers.DocumentBuilderFactory class Finestra : JFrame() { init { var doc: Document // sent\u00e8ncies per a omplir doc defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1,BorderLayout.NORTH) add(panell2,BorderLayout.CENTER) val llistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(llistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"),BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener{ // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { Finestra().isVisible = true } } Exercici 3_5 Fer un programa en el fitxer Kotlin Ex3_5_PassarRutesObjJSON.kt que passe el fitxer Rutes.obj a un fitxer JSON Rutes.json amb aquest aspecte: { \"rutes\": [ { \"nom\": \"Pujada a Penyagolosa\", \"desnivell\": 530, \"desnivellAcumulat\": 530, \"llistaDePunts\": [ { \"nom\": \"Sant Joan\", \"coord\": { \"latitud\": 40.251036, \"longitud\": -0.354223 } }, ... ] }, ... ] } Com que ja tenim creades les classes Ruta , PuntGeo i Coord , el m\u00e9s c\u00f2mode ser\u00e0 utilitzar Moshi . Tan sols ens far\u00e0 falta una classe que ho englobe tot: class Rutes(var rutes: MutableList<Ruta> = mutableListOf<Ruta>()) Exercici 3_6 Replicar l'exercici 3_4, per\u00f2 ara llegint del fitxer Rutes.json , en compte de Rutes.xml Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.json i que aparega el nom de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas, igual que en l'exercici 3_4, ens conv\u00e9 getSelectedIndex() . I com que ja tenim definides les classes, ens conv\u00e9 utilitzar Moshi . Aquest seria l'esquelet del programa. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Ex3_6_VisRutaJSON.kt : import javax.swing.* import java.awt.* import com.squareup.moshi.Moshi import java.io.File class FinestraJSON : JFrame() { init { var llistaRutes: ArrayList<Ruta> // sent\u00e8ncies per a omplir llistaRutes defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JSON: Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) var nomsLlistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(nomsLlistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"), BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener { // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraJSON().isVisible = true } } Exercici 3_7 (voluntari) Per a practicar un poquet m\u00e9s, anem a fer un altre exercici per a construir un fitxer JSON per\u00f2 ara amb la llibreria org.json Feu un programa en el fitxer Kotlin anomenat Ex3_7_PassarCotxesXMLJSON.kt , * que haur\u00e0 de passar el fitxer *cotxes.xml al fitxer cotxes.json . No tenim creades les classes dels cotxes, i per aix\u00f2 utilitzarem la llibreria org.json . Aquest \u00e9s el fitxer cotxes.xml : ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg I aquest ha de ser l'aspecte de cotxes.json : { \"oferta\": { \"vehiculos\": [ { \"marca\": \"ford\", \"modelo\": { \"color\": \"gris\", \"nombre_modelo\": \"focus\" }, \"motor\": { \"combustible\": \"gasolina\", \"nombre_motor\": \"duratorc 1.4\" }, \"matricula\": \"1234AAA\", \"kilometros\": \"12500\", \"precio_inicial\": \"12000\", \"precio_oferta\": \"10000\", \"extra\": [ { \"valor\": \"250\", \"nombre_extra\": \"pintura metalizada\" }, { \"valor\": \"300\", \"nombre_extra\": \"llantas\" } ], \"foto\": [ \"11325.jpg\", \"11326.jpg\" ] }, { \"marca\": \"ford\", \"modelo\": { \"color\": \"gris\", \"nombre_modelo\": \"focus\" }, \"motor\": { \"combustible\": \"diesel\", \"nombre_motor\": \"duratorc 2.0\" }, \"matricula\": \"1235AAA\", \"kilometros\": \"125000\", \"precio_inicial\": \"10000\", \"precio_oferta\": \"9000\", \"extra\": [ { \"valor\": \"250\", \"nombre_extra\": \"pintura metalizada\" }, { \"valor\": \"200\", \"nombre_extra\": \"spoiler trasero\" }, { \"valor\": \"500\", \"nombre_extra\": \"climatizador\" } ], \"foto\": [ \"11327.jpg\", \"11328.jpg\" ] } ] } } Exercici 3.8 (voluntari) Visualitzar en un programa gr\u00e0fic l'estat actual de Bicicas, agafant-lo directament de la p\u00e0gina http://gestiona.bicicas.es/apps/apps.php . En el m\u00e8tode agafarBicicas() farem les instruccions per agafar-lo directament d'Internet, utilitzant un URL , en el qual: Inicialitzarem amb la p\u00e0gina que busquem Obrirem la connexi\u00f3 amb el m\u00e8tode openConnection() Despr\u00e9s obtindrem el contingut amb el m\u00e8tode getInputStream() , que com el seu nom indica ser\u00e0 un InputStream En el m\u00e8tode mostrarEstacions() introduirem les instruccions per a visualitzar les estacions, utilitzant un JList (el que est\u00e0 a la part de l'esquerra), que s'ha de construir a partir d'un DefaultListModel . Per anar col\u00b7locant els diferents elements del JList, els haurem d'anar afegint al DefaultListModel , i aniran apareixent en el JList. Intentarem mostrar el n\u00famero d'estaci\u00f3, nom i n\u00famero de bicicletes (posicions ocupades) i el total de posicions. El m\u00e8tode visualitzaEstacio() s'activa quan seleccionem un element del JList, i en ell mostrarem les propietats de l'estaci\u00f3 seleccionada en el TextArea que est\u00e0 a la part de la dreta. Aquest seria l'aspecte: Aquest \u00e9s l'esquelet. Copieu-lo en un fitxer Kotlin anomenat Ex3_8_VisBicicasJSONList.kt : import javax.swing.* import java.awt.* import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.net.URL import java.io.InputStreamReader class FinestraBicicas : JFrame() { var estacions = JSONArray() var listModel = DefaultListModel<String>() var list = JList(listModel) var area = JTextArea(5, 15) init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JSON: Vista detallada BICICAS\") setSize(800, 800) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(GridLayout(1, 2)) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) list.setForeground(Color.blue) var scroll1 = JScrollPane(list) var scroll2 = JScrollPane(area) panell2.add(scroll1) panell2.add(scroll2) panell1.add(JLabel(\"LListat actual BICICAS\")) agafarBicicas() mostrarEstacions() list.addListSelectionListener() { if (list.getSelectedIndex() >= 0) visualitzaEstacio(list.getSelectedIndex()) } } fun agafarBicicas() { // Instruccions per a llegir de la p\u00e0gina de Bicicas i col\u00b7locar en arrel val bicicas = URL(\"http://gestiona.bicicas.es/apps/apps.php\"); val arrel = (JSONTokener(bicicas.openConnection().getInputStream()).nextValue() as JSONArray).get(0) as JSONObject // Instruccions per a col\u00b7locar les estacions en estacions (JsonArray) } fun mostrarEstacions() { // Instruccions per a introduir en el JList les estacions // La manera d'anar introduint informaci\u00f3 en el JList \u00e9s a trav\u00e9s del DefaultListModel: // listModel.addElement(\"Linia que es vol introduir \") } fun visualitzaEstacio(numEst: Int) { // Instruccions per a mostrar les caracter\u00edstiques en el area, el JTextArea de la dreta anomenat area } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraBicicas().isVisible = true } } `` Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercicis"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_1","text":"En el projecte anomenat Tema3 , crea't un paquet anomenat exercicis on col\u00b7locarem tot el relatiu als exercicis d'aquest tema. Copia't dins del projecte el fitxer Rutes.dat que us passar\u00e0 el professor. En ell tenim dades pr\u00e8viament guardades que seran unes rutes consistents en una s\u00e8rie de punts amb una descripci\u00f3. Cada punt seran unes coordenades (com en un mapa). L'estructura de les dades guardades \u00e9s la seg\u00fcent nom de la ruta (string) desnivell (int) desnivell acumulat (int) n\u00famero de punts (int) Per cada punt: nom (string) latitud (double) longitud (double) Observa que la quarta dada \u00e9s un enter amb el n\u00famero de punts de la ruta. Fes un programa (amb fun main() ) en el fitxer Kotlin Ex3_1_LlegirRutesSerial.kt que agafe les dades del fitxer (hi ha 2 rutes, per\u00f2 ho heu de fer gen\u00e8ric per a un n\u00famero indeterminat de rutes) i les traga per pantalla amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) Ruta: La Magdalena Desnivell: 51 Desnivell acumulat: 84 T\u00e9 7 punts Punt 1: Primer Mol\u00ed (39.99385,-0.032941) Punt 2: Segon Mol\u00ed (39.99628,-0.029427) Punt 3: Camin\u00e0s (40.00513,-0.022569) Punt 4: Riu Sec (40.006765,-0.02237) Punt 5: Sant Roc (40.017906,-0.02289) Punt 6: Explanada (40.034048,-0.00633) Punt 7: La Magdalena (40.034519,-0.005856)","title":"Exercici 3_1"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_2","text":"****Construeix les seg\u00fcents classes: Coordenades , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar- li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: latitud (double) longitud (double) No caldr\u00e0 contructor, ni getters ni setters, ja que Kotlin els genera autom\u00e0ticament PuntGeo , que derivar\u00e0 de Serializable (i que \u00e9s convenient posar-li el n\u00famero de versi\u00f3 per defecte: private const val serialVersionUID: Long = 1 ). Podeu consultar la classe Ruta que us passe per veure la manera de derivar de Serializable i posar-li n\u00famero de s\u00e8rie. Contindr\u00e0: nom (String) coord (Coordenades) Ruta . Aquesta classe us la passar\u00e0 el professor. Tamb\u00e9 implementa Serializable i cont\u00e9: nom (String)**** desnivell (int) desnivellAcumulat (int) llistaDePunts : un ArrayList de PuntGeo Observa com per a m\u00e9s comoditat t\u00e9 els m\u00e8todes: addPunt(PuntGeo) , que afegir\u00e0 un nou PuntGeo a la llista getPunt(int) , al qual se li passa l'\u00edndex del punt que es vol i torna tot aquest punt getPuntNom(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 el seu nom getPuntLatitud(int) ****, al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua latitud getPuntLongitud(int) , al qual se li passa l'\u00edndex del punt que es vol i tornar\u00e0 la seua longitud size() , que ens d\u00f3na el n\u00famero de punts guardats en la llista. L'\u00fanic que has de fer en aquesta classe \u00e9s: Fes un m\u00e8tode nou en la classe Ruta anomenat mostraRuta() , que mostre el contingut de la ruta amb aquest aspecte: Ruta: Pujada a Penyagolosa Desnivell: 530 Desnivell Acumulat: 530 T\u00e9 5 punts Punt 1: Sant Joan (40.251036,-0.354223) Punt 2: Encreuament (40.25156,-0.352507) Punt 3: Barranc de la Pegunta (40.247318,-0.351713) Punt 4: El Corralico (40.231708,-0.348859) Punt 5: Penyagolosa (40.222632,-0.350339) En un fitxer Kotlin anomenat Ex3_2_PassarRutesSerialObj.kt , fes el programa que passe del fitxe Rutes.dat al fitxer Rutes.obj . \u00c9s a dir, has d'anar agafant la informaci\u00f3 del fitxer Rutes.dat , guardar la informaci\u00f3 en un objecte Ruta , visualitzar la seua informaci\u00f3 amb mostraRuta() i per \u00faltim guardar la informaci\u00f3 de l'objecte en un fitxer anomenat Rutes.obj . I aix\u00f2 fins el final de fitxer (hi ha 2 rutes) En un fitxer Kotlin anomenat Ex3_2_LlegirRutesObj.kt , llig les rutes guardades en el fitxer Rutes.obj i mostra-les per pantalla utilitzant el m\u00e8tode mostraRuta()","title":"Exercici 3_2"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_3","text":"Fes un programa en el fitxer Ex3_3_PassarRutesObjXML.kt (amb main) que passe el fitxer Rutes.obj a un fitxer XML anomenat Rutes.xml amb aquest aspecte. Els punts suspensius indiquen que hi ha m\u00e9s d'un punt en cada ruta, i que hi ha m\u00e9s d'una ruta Pujada a Penyagolosa 530 530 Sant Joan ... ... ... ...","title":"Exercici 3_3"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_4","text":"Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.xml per a que apareguen els noms de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas ens conv\u00e9 getSelectedIndex() , ja que el n\u00famero d'ordre de l'element seleccionat ser\u00e0 el mateix que el n\u00famero d'ordre de la ruta que busquem en el NodeList doc.getElementsByTagName(\"ruta\") L'esquelet del programa seria aquest. Copieu-lo en un fitxer Kotlin anomenat Ex3_4_VisRutesXML.kt : import javax.swing.* import java.awt.* import org.w3c.dom.Document import org.w3c.dom.Element import javax.xml.parsers.DocumentBuilderFactory class Finestra : JFrame() { init { var doc: Document // sent\u00e8ncies per a omplir doc defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1,BorderLayout.NORTH) add(panell2,BorderLayout.CENTER) val llistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(llistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"),BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener{ // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { Finestra().isVisible = true } }","title":"Exercici 3_4"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_5","text":"Fer un programa en el fitxer Kotlin Ex3_5_PassarRutesObjJSON.kt que passe el fitxer Rutes.obj a un fitxer JSON Rutes.json amb aquest aspecte: { \"rutes\": [ { \"nom\": \"Pujada a Penyagolosa\", \"desnivell\": 530, \"desnivellAcumulat\": 530, \"llistaDePunts\": [ { \"nom\": \"Sant Joan\", \"coord\": { \"latitud\": 40.251036, \"longitud\": -0.354223 } }, ... ] }, ... ] } Com que ja tenim creades les classes Ruta , PuntGeo i Coord , el m\u00e9s c\u00f2mode ser\u00e0 utilitzar Moshi . Tan sols ens far\u00e0 falta una classe que ho englobe tot: class Rutes(var rutes: MutableList<Ruta> = mutableListOf<Ruta>())","title":"Exercici 3_5"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_6","text":"Replicar l'exercici 3_4, per\u00f2 ara llegint del fitxer Rutes.json , en compte de Rutes.xml Fer una aplicaci\u00f3 gr\u00e0fica que llegir\u00e0 el fitxer Rutes.json i que aparega el nom de les rutes en un JComboBox. Quan se seleccione una, ha d'apar\u00e8ixer la llista de punts (nom, latitud i longitud) en un JTextArea. L'aspecte podria ser el seg\u00fcent: Hi ha dos m\u00e8todes per a saber quin \u00e9s l'element seleccionat del JComboBox : getSelectedItem() torna un String amb l'element seleccionat getSelectedIndex() torna un enter amb el n\u00famero d'ordre de l'element seleccionat (0 per al primer; 1 per al segon; ...) Observeu com en aquest cas, igual que en l'exercici 3_4, ens conv\u00e9 getSelectedIndex() . I com que ja tenim definides les classes, ens conv\u00e9 utilitzar Moshi . Aquest seria l'esquelet del programa. Copieu el seg\u00fcent codi en un fitxer Kotlin anomenat Ex3_6_VisRutaJSON.kt : import javax.swing.* import java.awt.* import com.squareup.moshi.Moshi import java.io.File class FinestraJSON : JFrame() { init { var llistaRutes: ArrayList<Ruta> // sent\u00e8ncies per a omplir llistaRutes defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JSON: Punts d'una ruta\") setSize(400, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(BorderLayout()) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) var nomsLlistaRutes = arrayListOf<String>() // sent\u00e8ncies per a omplir l'ArrayList anterior amb el nom de les rutes val combo = JComboBox(nomsLlistaRutes.toArray()) panell1.add(combo) panell2.add(JLabel(\"Llista de punts de la ruta:\"), BorderLayout.NORTH) val area = JTextArea() panell2.add(area) combo.addActionListener { // accions quan s'ha seleccionat un element del combobox, // i que han de consistir en omplir el JTextArea } } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraJSON().isVisible = true } }","title":"Exercici 3_6"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-3_7-voluntari","text":"Per a practicar un poquet m\u00e9s, anem a fer un altre exercici per a construir un fitxer JSON per\u00f2 ara amb la llibreria org.json Feu un programa en el fitxer Kotlin anomenat Ex3_7_PassarCotxesXMLJSON.kt , * que haur\u00e0 de passar el fitxer *cotxes.xml al fitxer cotxes.json . No tenim creades les classes dels cotxes, i per aix\u00f2 utilitzarem la llibreria org.json . Aquest \u00e9s el fitxer cotxes.xml : ford focus duratorc 1.4 1234AAA 12500 12000 10000 pintura metalizada llantas 11325.jpg 11326.jpg ford focus duratorc 2.0 1235AAA 125000 10000 9000 pintura metalizada spoiler trasero climatizador 11327.jpg 11328.jpg I aquest ha de ser l'aspecte de cotxes.json : { \"oferta\": { \"vehiculos\": [ { \"marca\": \"ford\", \"modelo\": { \"color\": \"gris\", \"nombre_modelo\": \"focus\" }, \"motor\": { \"combustible\": \"gasolina\", \"nombre_motor\": \"duratorc 1.4\" }, \"matricula\": \"1234AAA\", \"kilometros\": \"12500\", \"precio_inicial\": \"12000\", \"precio_oferta\": \"10000\", \"extra\": [ { \"valor\": \"250\", \"nombre_extra\": \"pintura metalizada\" }, { \"valor\": \"300\", \"nombre_extra\": \"llantas\" } ], \"foto\": [ \"11325.jpg\", \"11326.jpg\" ] }, { \"marca\": \"ford\", \"modelo\": { \"color\": \"gris\", \"nombre_modelo\": \"focus\" }, \"motor\": { \"combustible\": \"diesel\", \"nombre_motor\": \"duratorc 2.0\" }, \"matricula\": \"1235AAA\", \"kilometros\": \"125000\", \"precio_inicial\": \"10000\", \"precio_oferta\": \"9000\", \"extra\": [ { \"valor\": \"250\", \"nombre_extra\": \"pintura metalizada\" }, { \"valor\": \"200\", \"nombre_extra\": \"spoiler trasero\" }, { \"valor\": \"500\", \"nombre_extra\": \"climatizador\" } ], \"foto\": [ \"11327.jpg\", \"11328.jpg\" ] } ] } }","title":"Exercici 3_7 (voluntari)"},{"location":"AD_T3_Fitxers_de_diferents_formats/exercicis/#exercici-38-voluntari","text":"Visualitzar en un programa gr\u00e0fic l'estat actual de Bicicas, agafant-lo directament de la p\u00e0gina http://gestiona.bicicas.es/apps/apps.php . En el m\u00e8tode agafarBicicas() farem les instruccions per agafar-lo directament d'Internet, utilitzant un URL , en el qual: Inicialitzarem amb la p\u00e0gina que busquem Obrirem la connexi\u00f3 amb el m\u00e8tode openConnection() Despr\u00e9s obtindrem el contingut amb el m\u00e8tode getInputStream() , que com el seu nom indica ser\u00e0 un InputStream En el m\u00e8tode mostrarEstacions() introduirem les instruccions per a visualitzar les estacions, utilitzant un JList (el que est\u00e0 a la part de l'esquerra), que s'ha de construir a partir d'un DefaultListModel . Per anar col\u00b7locant els diferents elements del JList, els haurem d'anar afegint al DefaultListModel , i aniran apareixent en el JList. Intentarem mostrar el n\u00famero d'estaci\u00f3, nom i n\u00famero de bicicletes (posicions ocupades) i el total de posicions. El m\u00e8tode visualitzaEstacio() s'activa quan seleccionem un element del JList, i en ell mostrarem les propietats de l'estaci\u00f3 seleccionada en el TextArea que est\u00e0 a la part de la dreta. Aquest seria l'aspecte: Aquest \u00e9s l'esquelet. Copieu-lo en un fitxer Kotlin anomenat Ex3_8_VisBicicasJSONList.kt : import javax.swing.* import java.awt.* import org.json.JSONTokener import org.json.JSONObject import org.json.JSONArray import java.net.URL import java.io.InputStreamReader class FinestraBicicas : JFrame() { var estacions = JSONArray() var listModel = DefaultListModel<String>() var list = JList(listModel) var area = JTextArea(5, 15) init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"JSON: Vista detallada BICICAS\") setSize(800, 800) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) val panell2 = JPanel(GridLayout(1, 2)) add(panell1, BorderLayout.NORTH) add(panell2, BorderLayout.CENTER) list.setForeground(Color.blue) var scroll1 = JScrollPane(list) var scroll2 = JScrollPane(area) panell2.add(scroll1) panell2.add(scroll2) panell1.add(JLabel(\"LListat actual BICICAS\")) agafarBicicas() mostrarEstacions() list.addListSelectionListener() { if (list.getSelectedIndex() >= 0) visualitzaEstacio(list.getSelectedIndex()) } } fun agafarBicicas() { // Instruccions per a llegir de la p\u00e0gina de Bicicas i col\u00b7locar en arrel val bicicas = URL(\"http://gestiona.bicicas.es/apps/apps.php\"); val arrel = (JSONTokener(bicicas.openConnection().getInputStream()).nextValue() as JSONArray).get(0) as JSONObject // Instruccions per a col\u00b7locar les estacions en estacions (JsonArray) } fun mostrarEstacions() { // Instruccions per a introduir en el JList les estacions // La manera d'anar introduint informaci\u00f3 en el JList \u00e9s a trav\u00e9s del DefaultListModel: // listModel.addElement(\"Linia que es vol introduir \") } fun visualitzaEstacio(numEst: Int) { // Instruccions per a mostrar les caracter\u00edstiques en el area, el JTextArea de la dreta anomenat area } } fun main(args: Array<String>) { EventQueue.invokeLater { FinestraBicicas().isVisible = true } } `` Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici 3.8 (voluntari)"},{"location":"AD_T3_Fitxers_de_diferents_formats/objectius/","text":"Acc\u00e9s a Dades Objectius Objectius Aquest tema servir\u00e0 per a finalitzar el contacte amb els fitxers. Una vegada hem vist com accedir als fitxers i al seu contingut, ara \u00e9s el moment de plantejar-nos com guardar dades de diferents tipus, com guardar objectes, ... , farem menci\u00f3 especial als fitxers XML i al format JSON Per una banda es gestionen fitxers amb dades de diferents tipus, ben al contrari que en els fitxers de text, o els exemples d'agafar un fitxer i tractar tots els bytes de la mateixa manera. Per una altra els fitxers d'acc\u00e9s directe (tamb\u00e9 anomenats d'acc\u00e9s relatiu o aleatori). Tamb\u00e9 s'introdueix el tema de la seriaci\u00f3 d'objectes, \u00e9s a dir, intentar guardar objectes directament en fitxers. Una t\u00e8cnica senzilla per\u00f2 que t\u00e9 inconvenients. Despr\u00e9s es tracten els documents XML, no com un fitxer de text (que ho \u00e9s), sin\u00f3 amb un tractament espec\u00edfic per poder accedir a la informaci\u00f3 jerarquitzada d'un document XML. I finalment farem el mateix amb el format JSON Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T3_Fitxers_de_diferents_formats/objectius/#objectius","text":"","title":"Objectius"},{"location":"AD_T3_Fitxers_de_diferents_formats/objectius/#objectius_1","text":"Aquest tema servir\u00e0 per a finalitzar el contacte amb els fitxers. Una vegada hem vist com accedir als fitxers i al seu contingut, ara \u00e9s el moment de plantejar-nos com guardar dades de diferents tipus, com guardar objectes, ... , farem menci\u00f3 especial als fitxers XML i al format JSON Per una banda es gestionen fitxers amb dades de diferents tipus, ben al contrari que en els fitxers de text, o els exemples d'agafar un fitxer i tractar tots els bytes de la mateixa manera. Per una altra els fitxers d'acc\u00e9s directe (tamb\u00e9 anomenats d'acc\u00e9s relatiu o aleatori). Tamb\u00e9 s'introdueix el tema de la seriaci\u00f3 d'objectes, \u00e9s a dir, intentar guardar objectes directament en fitxers. Una t\u00e8cnica senzilla per\u00f2 que t\u00e9 inconvenients. Despr\u00e9s es tracten els documents XML, no com un fitxer de text (que ho \u00e9s), sin\u00f3 amb un tractament espec\u00edfic per poder accedir a la informaci\u00f3 jerarquitzada d'un document XML. I finalment farem el mateix amb el format JSON Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"}]}